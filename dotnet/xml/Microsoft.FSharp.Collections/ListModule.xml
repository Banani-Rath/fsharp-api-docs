<Type Name="ListModule" FullName="Microsoft.FSharp.Collections.ListModule">
  <TypeSignature Language="C#" Value="public static class ListModule" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed ListModule extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.FSharp.Collections.ListModule" />
  <AssemblyInfo>
    <AssemblyName>FSharp.Core</AssemblyName>
    <AssemblyVersion>4.4.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationMapping(Microsoft.FSharp.Core.SourceConstructFlags.Module)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationRepresentation(Microsoft.FSharp.Core.CompilationRepresentationFlags.ModuleSuffix)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.RequireQualifiedAccess</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Basic operations on lists.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AllPairs&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;Tuple&lt;T1,T2&gt;&gt; AllPairs&lt;T1,T2&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T1&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T2&gt; list2);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;class System.Tuple`2&lt;!!T1, !!T2&gt;&gt; AllPairs&lt;T1, T2&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T1&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T2&gt; list2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.AllPairs``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("allPairs")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;System.Tuple&lt;T1,T2&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="list1">The first input list.</param>
        <param name="list2">The second input list.</param>
        <summary>Returns a new list that contains the cartesian product of the two input lists.</summary>
        <returns>The resulting list of pairs.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Append&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list2);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Append&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Append``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("append")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list1">The first input list.</param>
        <param name="list2">The second input list.</param>
        <summary>Returns a new list that contains the elements of the first list
 followed by elements of the second.</summary>
        <returns>The resulting list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Average&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Average&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Average``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("average")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns the average of the elements in the list.</summary>
        <returns>The resulting average.</returns>
        <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty.</remarks>
        <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="AverageBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult AverageBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult AverageBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("averageBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">The function to transform the list elements into the type to be averaged.</param>
        <param name="list">The input list.</param>
        <summary>Returns the average of the elements generated by applying the function to each element of the list.</summary>
        <returns>The resulting average.</returns>
        <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty.</remarks>
        <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt; Choose&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt; chooser, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!TResult&gt; Choose&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt;&gt; chooser, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("choose")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chooser" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="chooser">The function to generate options from the elements.</param>
        <param name="list">The input list.</param>
        <summary>Applies the given function to each element of the list. Returns
 the list comprised of the results <c>x</c> for each element where
 the function returns Some(x)</summary>
        <returns>The list comprising the values selected from the chooser function.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChunkBySize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Collections.FSharpList&lt;T&gt;&gt; ChunkBySize&lt;T&gt; (int chunkSize, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt;&gt; ChunkBySize&lt;T&gt;(int32 chunkSize, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.ChunkBySize``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("chunkBySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Collections.FSharpList&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chunkSize" Type="System.Int32" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="chunkSize">The maximum size of each chunk.</param>
        <param name="list">The input list.</param>
        <summary>Divides the input list into chunks of size at most <c>chunkSize</c>.</summary>
        <returns>The list divided into chunks.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when <c>chunkSize</c> is not positive.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt; Collect&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt;&gt; mapping, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!TResult&gt; Collect&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!TResult&gt;&gt; mapping, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Collections.FSharpList{``1}},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("collect")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt;&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform each input element into a sublist to be concatenated.</param>
        <param name="list">The input list.</param>
        <summary>For each element of the list, applies the given function. Concatenates all the results and return the combined list.</summary>
        <returns>The concatenation of the transformed sublists.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int CompareWith&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,int&gt;&gt; comparer, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list2);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 CompareWith&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, int32&gt;&gt; comparer, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.CompareWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("compareWith")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Int32&gt;&gt;" />
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="comparer">A function that takes an element from each list and returns an int.
 If it evaluates to a non-zero value iteration is stopped and that value is returned.</param>
        <param name="list1">The first input list.</param>
        <param name="list2">The second input list.</param>
        <summary>Compares two lists using the given comparison function, element by element.</summary>
        <returns>Returns the first non-zero result from the comparison function. If the first list has a 
 larger element, the return value is always positive. If the second list has a larger 
 element, the return value is always negative. When the elements are equal in the two 
 lists, 1 is returned if the first list is longer, 0 is returned if they are equal in 
 length, and -1 is returned when the second list is longer.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;Microsoft.FSharp.Collections.FSharpList&lt;T&gt;&gt; lists);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt;&gt; lists) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Concat``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Collections.FSharpList{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("concat")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="lists" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.FSharp.Collections.FSharpList&lt;T&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lists">The input sequence of lists.</param>
        <summary>Returns a new list that contains the elements of each the lists in order.</summary>
        <returns>The resulting concatenated list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;T&gt; (T value, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool Contains&lt;T&gt;(!!T value, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Contains``1(``0,Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("contains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
        <Parameter Name="source" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The value to locate in the input list.</param>
        <param name="source">The input list.</param>
        <summary>Tests if the list contains the specified element.</summary>
        <returns>True if the input list contains the specified element; false otherwise.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CountBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;Tuple&lt;TKey,int&gt;&gt; CountBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;class System.Tuple`2&lt;!!TKey, int32&gt;&gt; CountBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.CountBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("countBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;System.Tuple&lt;TKey,System.Int32&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">A function transforming each item of the input list into a key to be
 compared against the others.</param>
        <param name="list">The input list.</param>
        <summary>Applies a key-generating function to each element of a list and returns a list yielding unique
 keys and their number of occurrences in the original list.</summary>
        <returns>The result list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Distinct&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Distinct&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Distinct``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("distinct")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns a list that contains no duplicate entries according to generic hash and
 equality comparisons on the entries.
 If an element occurs multiple times in the list then the later occurrences are discarded.</summary>
        <returns>The result list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DistinctBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; DistinctBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; DistinctBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.DistinctBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("distinctBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">A function transforming the list items into comparable keys.</param>
        <param name="list">The input list.</param>
        <summary>Returns a list that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the list then the later occurrences are discarded.</summary>
        <returns>The result list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Empty``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("empty")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.GeneralizableValue</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Returns an empty list of the given type.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExactlyOne&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ExactlyOne&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T ExactlyOne&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.ExactlyOne``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exactlyOne")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns the only element of the list.</summary>
        <returns>The only element of the list.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input does not have precisely one element.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Except&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; itemsToExclude, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Except&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; itemsToExclude, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Except``1(System.Collections.Generic.IEnumerable{``0},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("except")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="itemsToExclude" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="itemsToExclude">A sequence whose elements that also occur in the input list will cause those elements to be
 removed from the result.</param>
        <param name="list">A list whose elements that are not also in itemsToExclude will be returned.</param>
        <summary>Returns a new list with the distinct elements of the input list which do not appear in the itemsToExclude sequence,
 using generic hash and equality comparisons to compare values.</summary>
        <returns>A list that contains the distinct elements of <c>list</c> that do not appear in <c>itemsToExclude</c>.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when itemsToExclude is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool Exists&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exists")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list">The input list.</param>
        <summary>Tests if any element of the list satisfies the given predicate.</summary>
        <returns>True if any element satisfies the predicate.</returns>
        <remarks>The predicate is applied to the elements of the input list. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,bool&gt;&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T1&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T2&gt; list2);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool Exists2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, bool&gt;&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T1&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T2&gt; list2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exists2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,System.Boolean&gt;&gt;" />
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list1">The first input list.</param>
        <param name="list2">The second input list.</param>
        <summary>Tests if any pair of corresponding elements of the lists satisfies the given predicate.</summary>
        <returns>True if any pair of elements satisfy the predicate.</returns>
        <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, if one collections is longer 
 than the other then the <c>System.ArgumentException</c> exception is raised. 
 Otherwise, false is returned.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="Filter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Filter&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Filter&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list">The input list.</param>
        <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true"</summary>
        <returns>A list containing only the elements that satisfy the predicate.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Find&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("find")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list">The input list.</param>
        <summary>Returns the first element for which the given function returns True.
 Raises <c>KeyNotFoundException</c> if no such element exists.</summary>
        <returns>The first element that satisfies the predicate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if the predicate evaluates to false for
 all the elements of the list.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T FindBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.FindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("findBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list">The input list.</param>
        <summary>Returns the last element for which the given function returns True.
 Raises <c>KeyNotFoundException</c> if no such element exists.</summary>
        <returns>The last element that satisfies the predicate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if the predicate evaluates to false for
 all the elements of the list.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FindIndex&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("findIndex")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list">The input list.</param>
        <summary>Returns the index of the first element in the list
 that satisfies the given predicate.
 Raises <c>KeyNotFoundException</c> if no such element exists.</summary>
        <returns>The index of the first element that satisfies the predicate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown if the predicate evaluates to false for all the
 elements of the list.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndexBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndexBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FindIndexBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.FindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("findIndexBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list">The input list.</param>
        <summary>Returns the index of the last element in the list
 that satisfies the given predicate.
 Raises <c>KeyNotFoundException</c> if no such element exists.</summary>
        <returns>The index of the last element that satisfies the predicate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown if the predicate evaluates to false for all the
 elements of the list.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fold&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState Fold&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt; folder, TState state, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState Fold&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TState&gt;&gt; folder, !!TState state, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("fold")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="state">The initial state.</param>
        <param name="list">The input list.</param>
        <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. Take the second argument, and apply the function to it
 and the first element of the list. Then feed this result into the function along
 with the second element and so on. Return the final result.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> then 
 computes <c>f (... (f s i0) i1 ...) iN</c>.</summary>
        <returns>The final state value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fold2&lt;T1,T2,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState Fold2&lt;T1,T2,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TState&gt;&gt;&gt; folder, TState state, Microsoft.FSharp.Collections.FSharpList&lt;T1&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T2&gt; list2);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState Fold2&lt;T1, T2, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TState&gt;&gt;&gt; folder, !!TState state, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T1&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T2&gt; list2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``2,Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("fold2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TState&gt;&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="state">The initial state.</param>
        <param name="list1">The first input list.</param>
        <param name="list2">The second input list.</param>
        <summary>Applies a function to corresponding elements of two collections, threading an accumulator argument
 through the computation. The collections must have identical sizes.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
 then computes <c>f (... (f s i0 j0)...) iN jN</c>.</summary>
        <returns>The final state value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FoldBack&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState FoldBack&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt; folder, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState FoldBack&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, !!TState&gt;&gt; folder, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Collections.FSharpList{``0},``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("foldBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="list">The input list.</param>
        <param name="state">The initial state.</param>
        <summary>Applies a function to each element of the collection, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then 
 computes <c>f i0 (...(f iN s))</c>.</summary>
        <returns>The state object after the folding function is applied to each element of the list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FoldBack2&lt;T1,T2,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState FoldBack2&lt;T1,T2,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;&gt; folder, Microsoft.FSharp.Collections.FSharpList&lt;T1&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T2&gt; list2, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState FoldBack2&lt;T1, T2, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, !!TState&gt;&gt;&gt; folder, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T1&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T2&gt; list2, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},``2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("foldBack2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;&gt;" />
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="list1">The first input list.</param>
        <param name="list2">The second input list.</param>
        <param name="state">The initial state.</param>
        <summary>Applies a function to corresponding elements of two collections, threading an accumulator argument
 through the computation. The collections must have identical sizes.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
 then computes <c>f i0 j0 (...(f iN jN s))</c>.</summary>
        <returns>The final state value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool ForAll&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("forall")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list">The input list.</param>
        <summary>Tests if all elements of the collection satisfy the given predicate.</summary>
        <returns>True if all of the elements satisfy the predicate.</returns>
        <remarks>The predicate is applied to the elements of the input list. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForAll2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,bool&gt;&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T1&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T2&gt; list2);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool ForAll2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, bool&gt;&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T1&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T2&gt; list2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("forall2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,System.Boolean&gt;&gt;" />
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list1">The first input list.</param>
        <param name="list2">The second input list.</param>
        <summary>Tests if all corresponding elements of the collection satisfy the given predicate pairwise.</summary>
        <returns>True if all of the pairs of elements satisfy the predicate.</returns>
        <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns false then the overall result is 
 false and no further elements are tested. Otherwise, if one collection is longer 
 than the other then the <c>System.ArgumentException</c> exception is raised. 
 Otherwise, true is returned.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input lists differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="Get&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Get&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Get&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Get``1(Microsoft.FSharp.Collections.FSharpList{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("nth")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("please use List.item")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <param name="index">The index to retrieve.</param>
        <summary>Indexes into the list. The first element has index 0.</summary>
        <returns>The value at the given index.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when the index is negative or the input list does not contain enough elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;Tuple&lt;TKey,Microsoft.FSharp.Collections.FSharpList&lt;T&gt;&gt;&gt; GroupBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;class System.Tuple`2&lt;!!TKey, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt;&gt;&gt; GroupBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.GroupBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("groupBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;System.Tuple&lt;TKey,Microsoft.FSharp.Collections.FSharpList&lt;T&gt;&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">A function that transforms an element of the list into a comparable key.</param>
        <param name="list">The input list.</param>
        <summary>Applies a key-generating function to each element of a list and yields a list of 
 unique keys. Each unique key contains a list of all elements that match 
 to this key.</summary>
        <returns>The result list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Head&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Head&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Head&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Head``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("head")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns the first element of the list.</summary>
        <returns>The first element of the list.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Indexed&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;Tuple&lt;int,T&gt;&gt; Indexed&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;class System.Tuple`2&lt;int32, !!T&gt;&gt; Indexed&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Indexed``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("indexed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;System.Tuple&lt;System.Int32,T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns a new list whose elements are the corresponding elements
 of the input list paired with the index (from 0) of each element.</summary>
        <returns>The list of indexed elements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Initialize&lt;T&gt; (int length, Microsoft.FSharp.Core.FSharpFunc&lt;int,T&gt; initializer);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Initialize&lt;T&gt;(int32 length, class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, !!T&gt; initializer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("init")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="initializer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="length">The length of the list to generate.</param>
        <param name="initializer">The function to generate an element from an index.</param>
        <summary>Creates a list by calling the given generator on each index.</summary>
        <returns>The list of generated elements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsEmpty&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool IsEmpty&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.IsEmpty``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("isEmpty")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns true if the list contains no elements, false otherwise.</summary>
        <returns>True if the list is empty.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Item&lt;T&gt; (int index, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Item&lt;T&gt;(int32 index, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Item``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("item")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="index">The index to retrieve.</param>
        <param name="list">The input list.</param>
        <summary>Indexes into the list. The first element has index 0.</summary>
        <returns>The value at the given index.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when the index is negative or the input list does not contain enough elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Iterate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Iterate&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt; action, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Iterate&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.Unit&gt; action, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="action">The function to apply to elements from the input list.</param>
        <param name="list">The input list.</param>
        <summary>Applies the given function to each element of the collection.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Iterate2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static void Iterate2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt; action, Microsoft.FSharp.Collections.FSharpList&lt;T1&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T2&gt; list2);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Iterate2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.Unit&gt;&gt; action, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T1&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T2&gt; list2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iter2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt;" />
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="action">The function to apply to pairs of elements from the input lists.</param>
        <param name="list1">The first input list.</param>
        <param name="list2">The second input list.</param>
        <summary>Applies the given function to two collections simultaneously. The
 collections must have identical size.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IterateIndexed&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IterateIndexed&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;&gt; action, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static void IterateIndexed&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.Unit&gt;&gt; action, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iteri")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="action">The function to apply to the elements of the list along with their index.</param>
        <param name="list">The input list.</param>
        <summary>Applies the given function to each element of the collection. The integer passed to the
 function indicates the index of element.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IterateIndexed2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static void IterateIndexed2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt;&gt; action, Microsoft.FSharp.Collections.FSharpList&lt;T1&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T2&gt; list2);" />
      <MemberSignature Language="ILAsm" Value=".method public static void IterateIndexed2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.Unit&gt;&gt;&gt; action, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T1&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T2&gt; list2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iteri2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt;&gt;" />
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="action">The function to apply to a pair of elements from the input lists along with their index.</param>
        <param name="list1">The first input list.</param>
        <param name="list2">The second input list.</param>
        <summary>Applies the given function to two collections simultaneously. The
 collections must have identical size. The integer passed to the
 function indicates the index of element.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Last&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Last&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Last``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("last")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns the last element of the list.</summary>
        <returns>The last element of the list.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input does not have any elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int Length&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Length&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Length``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("length")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns the length of the list.</summary>
        <returns>The length of the list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Map&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt; Map&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; mapping, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!TResult&gt; Map&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; mapping, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("map")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform elements from the input list.</param>
        <param name="list">The input list.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.</summary>
        <returns>The list of transformed elements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Map2&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt; Map2&lt;T1,T2,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt; mapping, Microsoft.FSharp.Collections.FSharpList&lt;T1&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T2&gt; list2);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!TResult&gt; Map2&lt;T1, T2, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TResult&gt;&gt; mapping, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T1&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T2&gt; list2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("map2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;" />
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform pairs of elements from the input lists.</param>
        <param name="list1">The first input list.</param>
        <param name="list2">The second input list.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise.</summary>
        <returns>The list of transformed elements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Map3&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt; Map3&lt;T1,T2,T3,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt; mapping, Microsoft.FSharp.Collections.FSharpList&lt;T1&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T2&gt; list2, Microsoft.FSharp.Collections.FSharpList&lt;T3&gt; list3);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!TResult&gt; Map3&lt;T1, T2, T3, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T3, !!TResult&gt;&gt;&gt; mapping, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T1&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T2&gt; list2, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T3&gt; list3) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("map3")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt;" />
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;" />
        <Parameter Name="list3" Type="Microsoft.FSharp.Collections.FSharpList&lt;T3&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform triples of elements from the input lists.</param>
        <param name="list1">The first input list.</param>
        <param name="list2">The second input list.</param>
        <param name="list3">The third input list.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the three collections simultaneously.</summary>
        <returns>The list of transformed elements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MapFold&lt;T,TState,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt;,TState&gt; MapFold&lt;T,TState,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,Tuple&lt;TResult,TState&gt;&gt;&gt; mapping, TState state, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;!!TResult&gt;, !!TState&gt; MapFold&lt;T, TState, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class System.Tuple`2&lt;!!TResult, !!TState&gt;&gt;&gt; mapping, !!TState state, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.MapFold``3(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``2,``1}}},``1,Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapFold")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt;,TState&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Tuple&lt;TResult,TState&gt;&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform elements from the input list and accumulate the final value.</param>
        <param name="state">The initial state.</param>
        <param name="list">The input list.</param>
        <summary>Combines map and fold. Builds a new list whose elements are the results of applying the given function
 to each of the elements of the input list. The function is also used to accumulate a final value.</summary>
        <returns>The list of transformed elements, and the final accumulated value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MapFoldBack&lt;T,TState,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt;,TState&gt; MapFoldBack&lt;T,TState,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,Tuple&lt;TResult,TState&gt;&gt;&gt; mapping, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;!!TResult&gt;, !!TState&gt; MapFoldBack&lt;T, TState, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class System.Tuple`2&lt;!!TResult, !!TState&gt;&gt;&gt; mapping, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.MapFoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},Microsoft.FSharp.Collections.FSharpList{``0},``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapFoldBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt;,TState&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,System.Tuple&lt;TResult,TState&gt;&gt;&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform elements from the input list and accumulate the final value.</param>
        <param name="list">The input list.</param>
        <param name="state">The initial state.</param>
        <summary>Combines map and foldBack. Builds a new list whose elements are the results of applying the given function
 to each of the elements of the input list. The function is also used to accumulate a final value.</summary>
        <returns>The list of transformed elements, and the final accumulated value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MapIndexed&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt; MapIndexed&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;&gt; mapping, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!TResult&gt; MapIndexed&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt;&gt; mapping, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapi")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform elements and their indices.</param>
        <param name="list">The input list.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.</summary>
        <returns>The list of transformed elements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MapIndexed2&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt; MapIndexed2&lt;T1,T2,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;&gt; mapping, Microsoft.FSharp.Collections.FSharpList&lt;T1&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T2&gt; list2);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!TResult&gt; MapIndexed2&lt;T1, T2, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TResult&gt;&gt;&gt; mapping, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T1&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T2&gt; list2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapi2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;&gt;" />
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform pairs of elements from the two lists and their index.</param>
        <param name="list1">The first input list.</param>
        <param name="list2">The second input list.</param>
        <summary>Like mapi, but mapping corresponding elements from two lists of equal length.</summary>
        <returns>The list of transformed elements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Max&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Max&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Max``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("max")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Return the greatest of all elements of the list, compared via Operators.max.</summary>
        <returns>The maximum element.</returns>
        <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty</remarks>
        <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static T MaxBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T MaxBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("maxBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">The function to transform the list elements into the type to be compared.</param>
        <param name="list">The input list.</param>
        <summary>Returns the greatest of all elements of the list, compared via Operators.max on the function result.</summary>
        <returns>The maximum element.</returns>
        <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty.</remarks>
        <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Min&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Min&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Min``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("min")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns the lowest of all elements of the list, compared via Operators.min.</summary>
        <returns>The minimum value.</returns>
        <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty</remarks>
        <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static T MinBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T MinBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("minBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">The function to transform list elements into the type to be compared.</param>
        <param name="list">The input list.</param>
        <summary>Returns the lowest of all elements of the list, compared via Operators.min on the function result</summary>
        <returns>The minimum value.</returns>
        <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty.</remarks>
        <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; OfArray&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; OfArray&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.OfArray``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("ofArray")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Builds a list from the given array.</summary>
        <returns>The list of elements from the array.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OfSeq&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; OfSeq&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; OfSeq&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("ofSeq")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Builds a new list from the given enumerable object.</summary>
        <returns>The list of elements from the sequence.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pairwise&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;Tuple&lt;T,T&gt;&gt; Pairwise&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;class System.Tuple`2&lt;!!T, !!T&gt;&gt; Pairwise&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Pairwise``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("pairwise")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;System.Tuple&lt;T,T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns a list of each element in the input list and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.</summary>
        <returns>The result list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Partition&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;Microsoft.FSharp.Collections.FSharpList&lt;T&gt;,Microsoft.FSharp.Collections.FSharpList&lt;T&gt;&gt; Partition&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt;, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt;&gt; Partition&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("partition")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;Microsoft.FSharp.Collections.FSharpList&lt;T&gt;,Microsoft.FSharp.Collections.FSharpList&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list">The input list.</param>
        <summary>Splits the collection into two collections, containing the 
 elements for which the given predicate returns True and False
 respectively. Element order is preserved in both of the created lists.</summary>
        <returns>A list containing the elements for which the predicate evaluated to false and a list
 containing the elements for which the predicate evaluated to true.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Permute&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Permute&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,int&gt; indexMap, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Permute&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, int32&gt; indexMap, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Permute``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("permute")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="indexMap" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,System.Int32&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="indexMap">The function to map input indices to output indices.</param>
        <param name="list">The input list.</param>
        <summary>Returns a list with all elements permuted according to the
 specified permutation.</summary>
        <returns>The permuted list.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when indexMap does not produce a valid permutation.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pick&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Pick&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt; chooser, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult Pick&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt;&gt; chooser, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("pick")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chooser" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="chooser">The function to generate options from the elements.</param>
        <param name="list">The input list.</param>
        <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some x. If no such
 element exists then raise <c>System.Collections.Generic.KeyNotFoundException</c></summary>
        <returns>The first resulting value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown when the list is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Reduce&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt; reduction, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Reduce&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!T&gt;&gt; reduction, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("reduce")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reduction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="reduction">The function to reduce two list elements to a single element.</param>
        <param name="list">The input list.</param>
        <summary>Apply a function to each element of the collection, threading an accumulator argument
 through the computation. Apply the function to the first two elements of the list.
 Then feed this result into the function along with the third element and so on. 
 Return the final result. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f (... (f i0 i1) i2 ...) iN</c>.</summary>
        <returns>The final reduced value.</returns>
        <remarks>Raises <c>System.ArgumentException</c> if <c>list</c> is empty</remarks>
        <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReduceBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ReduceBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt; reduction, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T ReduceBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!T&gt;&gt; reduction, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("reduceBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reduction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="reduction">A function that takes in the next-to-last element of the list and the
 current accumulated result to produce the next accumulated result.</param>
        <param name="list">The input list.</param>
        <summary>Applies a function to each element of the collection, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f i0 (...(f iN-1 iN))</c>.</summary>
        <returns>The final result of the reductions.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replicate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Replicate&lt;T&gt; (int count, T initial);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Replicate&lt;T&gt;(int32 count, !!T initial) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Replicate``1(System.Int32,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("replicate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="initial" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The number of elements to replicate.</param>
        <param name="initial">The value to replicate</param>
        <summary>Creates a list by replicating the given initial value.</summary>
        <returns>The generated list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Reverse&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Reverse&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Reverse``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("rev")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns a new list with the elements in reverse order.</summary>
        <returns>The reversed list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scan&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;TState&gt; Scan&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt; folder, TState state, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!TState&gt; Scan&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TState&gt;&gt; folder, !!TState state, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("scan")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;TState&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="state">The initial state.</param>
        <param name="list">The input list.</param>
        <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. Take the second argument, and apply the function to it
 and the first element of the list. Then feed this result into the function along
 with the second element and so on. Returns the list of intermediate results and the final result.</summary>
        <returns>The list of states.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScanBack&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;TState&gt; ScanBack&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt; folder, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!TState&gt; ScanBack&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, !!TState&gt;&gt; folder, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},Microsoft.FSharp.Collections.FSharpList{``0},``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("scanBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;TState&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="list">The input list.</param>
        <param name="state">The initial state.</param>
        <summary>Like <c>foldBack</c>, but returns both the intermediary and final results</summary>
        <returns>The list of states.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Singleton&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Singleton&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Singleton&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Singleton``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("singleton")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input item.</param>
        <summary>Returns a list that contains one item only.</summary>
        <returns>The result list of one item.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Skip&lt;T&gt; (int count, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Skip&lt;T&gt;(int32 count, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Skip``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("skip")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The number of elements to skip.</param>
        <param name="list">The input list.</param>
        <summary>Returns the list after removing the first N elements.</summary>
        <returns>The list after removing the first N elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when count is negative or exceeds the number of 
 elements in the list.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; SkipWhile&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; SkipWhile&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.SkipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("skipWhile")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function that evaluates an element of the list to a boolean value.</param>
        <param name="list">The input list.</param>
        <summary>Bypasses elements in a list while the given predicate returns True, and then returns
 the remaining elements of the list.</summary>
        <returns>The result list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Sort&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Sort&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Sort``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sort")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Sorts the given list using Operators.compare.</summary>
        <returns>The sorted list.</returns>
        <remarks>This is a stable sort, i.e. the original order of equal elements is preserved.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SortBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; SortBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; SortBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">The function to transform the list elements into the type to be compared.</param>
        <param name="list">The input list.</param>
        <summary>Sorts the given list using keys given by the given projection. Keys are compared using Operators.compare.</summary>
        <returns>The sorted list.</returns>
        <remarks>This is a stable sort, i.e. the original order of equal elements is preserved.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SortByDescending&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; SortByDescending&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; SortByDescending&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.SortByDescending``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortByDescending")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">The function to transform the list elements into the type to be compared.</param>
        <param name="list">The input list.</param>
        <summary>Sorts the given list in descending order using keys given by the given projection. Keys are compared using Operators.compare.</summary>
        <returns>The sorted list.</returns>
        <remarks>This is a stable sort, i.e. the original order of equal elements is preserved.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SortDescending&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; SortDescending&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; SortDescending&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.SortDescending``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortDescending")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Sorts the given list in descending order using Operators.compare.</summary>
        <returns>The sorted list.</returns>
        <remarks>This is a stable sort, i.e. the original order of equal elements is preserved.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SortWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; SortWith&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,int&gt;&gt; comparer, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; SortWith&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, int32&gt;&gt; comparer, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.SortWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortWith")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Int32&gt;&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="comparer">The function to compare the list elements.</param>
        <param name="list">The input list.</param>
        <summary>Sorts the given list using the given comparison function.</summary>
        <returns>The sorted list.</returns>
        <remarks>This is a stable sort, i.e. the original order of equal elements is preserved.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SplitAt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;Microsoft.FSharp.Collections.FSharpList&lt;T&gt;,Microsoft.FSharp.Collections.FSharpList&lt;T&gt;&gt; SplitAt&lt;T&gt; (int index, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt;, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt;&gt; SplitAt&lt;T&gt;(int32 index, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.SplitAt``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("splitAt")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;Microsoft.FSharp.Collections.FSharpList&lt;T&gt;,Microsoft.FSharp.Collections.FSharpList&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="index">The index at which the list is split.</param>
        <param name="list">The input list.</param>
        <summary>Splits a list into two lists, at the given index.</summary>
        <returns>The two split lists.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.InvalidOperationException">Thrown when split index exceeds the number of elements
 in the list.</exception>
      </Docs>
    </Member>
    <Member MemberName="SplitInto&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Collections.FSharpList&lt;T&gt;&gt; SplitInto&lt;T&gt; (int count, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt;&gt; SplitInto&lt;T&gt;(int32 count, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.SplitInto``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("splitInto")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Collections.FSharpList&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The maximum number of chunks.</param>
        <param name="list">The input list.</param>
        <summary>Splits the input list into at most <c>count</c> chunks.</summary>
        <returns>The list split into chunks.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when <c>count</c> is not positive.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sum&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Sum&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Sum``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sum")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns the sum of the elements in the list.</summary>
        <returns>The resulting sum.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SumBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult SumBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult SumBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sumBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">The function to transform the list elements into the type to be summed.</param>
        <param name="list">The input list.</param>
        <summary>Returns the sum of the results generated by applying the function to each element of the list.</summary>
        <returns>The resulting sum.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tail&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Tail&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Tail&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Tail``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tail")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns the list after removing the first element.</summary>
        <returns>The list after removing the first element.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when the list is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Take&lt;T&gt; (int count, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Take&lt;T&gt;(int32 count, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Take``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("take")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The number of items to take.</param>
        <param name="list">The input list.</param>
        <summary>Returns the first N elements of the list.</summary>
        <returns>The result list.</returns>
        <remarks>Throws <c>InvalidOperationException</c>
 if the count exceeds the number of elements in the list. <c>List.truncate</c>
 returns as many items as the list contains instead of throwing an exception.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input list is empty.</exception>
        <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the list.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; TakeWhile&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; TakeWhile&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.TakeWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("takeWhile")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function that evaluates to false when no more items should be returned.</param>
        <param name="list">The input list.</param>
        <summary>Returns a list that contains all elements of the original list while the 
 given predicate returns True, and then returns no further elements.</summary>
        <returns>The result list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] ToArray&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] ToArray&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.ToArray``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("toArray")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Builds an array from the given list.</summary>
        <returns>The array containing the elements of the list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSeq&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; ToSeq&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; ToSeq&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.ToSeq``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("toSeq")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Views the given list as a sequence.</summary>
        <returns>The sequence of elements in the list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Truncate&lt;T&gt; (int count, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Truncate&lt;T&gt;(int32 count, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Truncate``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("truncate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The maximum number of items to return.</param>
        <param name="list">To be added.</param>
        <summary>Returns at most N elements in a new list.</summary>
        <returns>The result list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFind&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryFind&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryFind&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFind")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list">The input list.</param>
        <summary>Returns the first element for which the given function returns True.
 Return None if no such element exists.</summary>
        <returns>The first element for which the predicate returns true, or None if
 every element evaluates to false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryFindBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryFindBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.TryFindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFindBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list">The input list.</param>
        <summary>Returns the last element for which the given function returns True.
 Return None if no such element exists.</summary>
        <returns>The last element for which the predicate returns true, or None if
 every element evaluates to false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;int&gt; TryFindIndex&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; TryFindIndex&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFindIndex")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list">The input list.</param>
        <summary>Returns the index of the first element in the list
 that satisfies the given predicate.
 Return <c>None</c> if no such element exists.</summary>
        <returns>The index of the first element for which the predicate returns true, or None if
 every element evaluates to false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFindIndexBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;int&gt; TryFindIndexBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; TryFindIndexBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.TryFindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFindIndexBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list">The input list.</param>
        <summary>Returns the index of the last element in the list
 that satisfies the given predicate.
 Return <c>None</c> if no such element exists.</summary>
        <returns>The index of the last element for which the predicate returns true, or None if
 every element evaluates to false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryHead&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryHead&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryHead&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.TryHead``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryHead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns the first element of the list, or
 <c>None</c> if the list is empty.</summary>
        <returns>The first element of the list or None.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryItem&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryItem&lt;T&gt; (int index, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryItem&lt;T&gt;(int32 index, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.TryItem``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryItem")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="index">The index to retrieve.</param>
        <param name="list">The input list.</param>
        <summary>Tries to find the nth element in the list.
 Returns <c>None</c> if index is negative or the list does not contain enough elements.</summary>
        <returns>The value at the given index or <c>None</c>.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryLast&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryLast&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.TryLast``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryLast")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Returns the last element of the list.
 Return <c>None</c> if no such element exists.</summary>
        <returns>The last element of the list or None.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryPick&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt; TryPick&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt; chooser, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt; TryPick&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt;&gt; chooser, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryPick")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chooser" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="chooser">The function to generate options from the elements.</param>
        <param name="list">The input list.</param>
        <summary>Applies the given function to successive elements, returning <c>Some(x)</c> the first
 result where function returns <c>Some(x)</c> for some x. If no such element 
 exists then return <c>None</c>.</summary>
        <returns>The first resulting value or None.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unfold&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Unfold&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpOption&lt;Tuple&lt;T,TState&gt;&gt;&gt; generator, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Unfold&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpOption`1&lt;class System.Tuple`2&lt;!!T, !!TState&gt;&gt;&gt; generator, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,``1}}},``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("unfold")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="generator" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpOption&lt;System.Tuple&lt;T,TState&gt;&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="generator">A function that takes in the current state and returns an option tuple of the next
 element of the list and the next state value.</param>
        <param name="state">The initial state value.</param>
        <summary>Returns a list that contains the elements generated by the given computation.
 The given initial <c>state</c> argument is passed to the element generator.</summary>
        <returns>The result list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unzip&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;,Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;&gt; Unzip&lt;T1,T2&gt; (Microsoft.FSharp.Collections.FSharpList&lt;Tuple&lt;T1,T2&gt;&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T1&gt;, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T2&gt;&gt; Unzip&lt;T1, T2&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;class System.Tuple`2&lt;!!T1, !!T2&gt;&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Unzip``2(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("unzip")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;,Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;System.Tuple&lt;T1,T2&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Splits a list of pairs into two lists.</summary>
        <returns>Two lists of split elements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unzip3&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;,Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;,Microsoft.FSharp.Collections.FSharpList&lt;T3&gt;&gt; Unzip3&lt;T1,T2,T3&gt; (Microsoft.FSharp.Collections.FSharpList&lt;Tuple&lt;T1,T2,T3&gt;&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`3&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T1&gt;, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T2&gt;, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T3&gt;&gt; Unzip3&lt;T1, T2, T3&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;class System.Tuple`3&lt;!!T1, !!T2, !!T3&gt;&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Unzip3``3(Microsoft.FSharp.Collections.FSharpList{System.Tuple{``0,``1,``2}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("unzip3")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;,Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;,Microsoft.FSharp.Collections.FSharpList&lt;T3&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Splits a list of triples into three lists.</summary>
        <returns>Three lists of split elements.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; Where&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; Where&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Where``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("where")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="list">The input list.</param>
        <summary>Returns a new list containing only the elements of the list
 for which the given predicate returns "true"</summary>
        <returns>A list containing only the elements that satisfy the predicate.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Windowed&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Collections.FSharpList&lt;T&gt;&gt; Windowed&lt;T&gt; (int windowSize, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt;&gt; Windowed&lt;T&gt;(int32 windowSize, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Windowed``1(System.Int32,Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("windowed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;Microsoft.FSharp.Collections.FSharpList&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="windowSize" Type="System.Int32" />
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="windowSize">The number of elements in each window.</param>
        <param name="list">The input list.</param>
        <summary>Returns a list of sliding windows containing elements drawn from the input
 list. Each window is returned as a fresh list.</summary>
        <returns>The result list.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when windowSize is not positive.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;Tuple&lt;T1,T2&gt;&gt; Zip&lt;T1,T2&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T1&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T2&gt; list2);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;class System.Tuple`2&lt;!!T1, !!T2&gt;&gt; Zip&lt;T1, T2&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T1&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T2&gt; list2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Zip``2(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("zip")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;System.Tuple&lt;T1,T2&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="list1">The first input list.</param>
        <param name="list2">The second input list.</param>
        <summary>Combines the two lists into a list of pairs. The two lists must have equal lengths.</summary>
        <returns>A single list containing pairs of matching elements from the input lists.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zip3&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;Tuple&lt;T1,T2,T3&gt;&gt; Zip3&lt;T1,T2,T3&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T1&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T2&gt; list2, Microsoft.FSharp.Collections.FSharpList&lt;T3&gt; list3);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;class System.Tuple`3&lt;!!T1, !!T2, !!T3&gt;&gt; Zip3&lt;T1, T2, T3&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T1&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T2&gt; list2, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T3&gt; list3) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ListModule.Zip3``3(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("zip3")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T1&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T2&gt;" />
        <Parameter Name="list3" Type="Microsoft.FSharp.Collections.FSharpList&lt;T3&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="list1">The first input list.</param>
        <param name="list2">The second input list.</param>
        <param name="list3">The third input list.</param>
        <summary>Combines the three lists into a list of triples. The lists must have equal lengths.</summary>
        <returns>A single list containing triples of matching elements from the input lists.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
