<Type Name="SeqModule" FullName="Microsoft.FSharp.Collections.SeqModule">
  <TypeSignature Language="C#" Value="public static class SeqModule" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed SeqModule extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.FSharp.Collections.SeqModule" />
  <AssemblyInfo>
    <AssemblyName>FSharp.Core</AssemblyName>
    <AssemblyVersion>4.4.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationMapping(Microsoft.FSharp.Core.SourceConstructFlags.Module)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationRepresentation(Microsoft.FSharp.Core.CompilationRepresentationFlags.ModuleSuffix)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.RequireQualifiedAccess</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Basic operations on IEnumerables.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AllPairs&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Tuple&lt;T1,T2&gt;&gt; AllPairs&lt;T1,T2&gt; (System.Collections.Generic.IEnumerable&lt;T1&gt; source1, System.Collections.Generic.IEnumerable&lt;T2&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;class System.Tuple`2&lt;!!T1, !!T2&gt;&gt; AllPairs&lt;T1, T2&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T1&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!T2&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.AllPairs``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("allPairs")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Tuple&lt;T1,T2&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="source1">The first sequence.</param>
        <param name="source2">The second sequence.</param>
        <summary>Returns a new sequence that contains the cartesian product of the two input sequences.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Append&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source1, System.Collections.Generic.IEnumerable&lt;T&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Append&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Append``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("append")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source1">The first sequence.</param>
        <param name="source2">The second sequence.</param>
        <summary>Wraps the two given enumerations as a single concatenated
 enumeration.</summary>
        <returns>The result sequence.</returns>
        <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed
 concurrently.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the two provided sequences is
 null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Average&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Average&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Average``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("average")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns the average of the elements in the sequence.</summary>
        <returns>The average.</returns>
        <remarks>The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property 
 associated with the element type.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input sequence has zero elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="AverageBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult AverageBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult AverageBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("averageBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">A function applied to transform each element of the sequence.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns the average of the results generated by applying the function to each element 
 of the sequence.</summary>
        <returns>The average.</returns>
        <remarks>The elements are averaged using the <c>+</c> operator, <c>DivideByInt</c> method and <c>Zero</c> property 
 associated with the generated type.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input sequence has zero elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cache&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Cache&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Cache&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Cache``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("cache")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns a sequence that corresponds to a cached version of the input sequence.
 This result sequence will have the same elements as the input sequence. The result 
 can be enumerated multiple times. The input sequence will be enumerated at most 
 once and only as far as is necessary.  Caching a sequence is typically useful when repeatedly
 evaluating items in the original sequence is computationally expensive or if
 iterating the sequence causes side-effects that the user does not want to be
 repeated multiple times.

 Enumeration of the result sequence is thread safe in the sense that multiple independent IEnumerator
 values may be used simultaneously from different threads (accesses to 
 the internal lookaside table are thread safe). Each individual IEnumerator
 is not typically thread safe and should not be accessed concurrently.</summary>
        <returns>The result sequence.</returns>
        <remarks>Once enumeration of the input sequence has started,
 it's enumerator will be kept live by this object until the enumeration has completed.
 At that point, the enumerator will be disposed. 

 The enumerator may be disposed and underlying cache storage released by 
 converting the returned sequence object to type IDisposable, and calling the Dispose method
 on this object. The sequence object may then be re-enumerated and a fresh enumerator will
 be used.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Cast&lt;T&gt; (System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Cast&lt;T&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Cast``1(System.Collections.IEnumerable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("cast")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Wraps a loosely-typed System.Collections sequence as a typed sequence.</summary>
        <returns>The result sequence.</returns>
        <remarks>The use of this function usually requires a type annotation.
 An incorrect type annotation may result in runtime type
 errors.
 Individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Choose&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt; chooser, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Choose&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt;&gt; chooser, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("choose")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chooser" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="chooser">A function to transform items of type T into options of type U.</param>
        <param name="source">The input sequence of type T.</param>
        <summary>Applies the given function to each element of the list. Return
 the list comprised of the results "x" for each element where
 the function returns Some(x).</summary>
        <returns>The result sequence.</returns>
        <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not
 be accessed concurrently.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ChunkBySize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T[]&gt; ChunkBySize&lt;T&gt; (int chunkSize, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T[]&gt; ChunkBySize&lt;T&gt;(int32 chunkSize, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.ChunkBySize``1(System.Int32,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("chunkBySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chunkSize" Type="System.Int32" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="chunkSize">The maximum size of each chunk.</param>
        <param name="source">The input sequence.</param>
        <summary>Divides the input sequence into chunks of size at most <c>chunkSize</c>.</summary>
        <returns>The sequence divided into chunks.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when <c>chunkSize</c> is not positive.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect&lt;T,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Collect&lt;T,TCollection,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TCollection&gt; mapping, System.Collections.Generic.IEnumerable&lt;T&gt; source) where TCollection : System.Collections.Generic.IEnumerable&lt;TResult&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Collect&lt;T, (class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;) TCollection, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TCollection&gt; mapping, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Collect``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("collect")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IEnumerable&lt;TResult&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TCollection&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TCollection">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">A function to transform elements of the input sequence into the sequences
 that will then be concatenated.</param>
        <param name="source">The input sequence.</param>
        <summary>Applies the given function to each element of the sequence and concatenates all the
 results.</summary>
        <returns>The result sequence.</returns>
        <remarks>Remember sequence is lazy, effects are delayed until it is enumerated.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int CompareWith&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,int&gt;&gt; comparer, System.Collections.Generic.IEnumerable&lt;T&gt; source1, System.Collections.Generic.IEnumerable&lt;T&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 CompareWith&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, int32&gt;&gt; comparer, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.CompareWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("compareWith")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Int32&gt;&gt;" />
        <Parameter Name="source1" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="comparer">A function that takes an element from each sequence and returns an int.
 If it evaluates to a non-zero value iteration is stopped and that value is returned.</param>
        <param name="source1">The first input sequence.</param>
        <param name="source2">The second input sequence.</param>
        <summary>Compares two sequences using the given comparison function, element by element.</summary>
        <returns>Returns the first non-zero result from the comparison function.  If the end of a sequence
 is reached it returns a -1 if the first sequence is shorter and a 1 if the second sequence
 is shorter.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input sequences
 is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TCollection,T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Concat&lt;TCollection,T&gt; (System.Collections.Generic.IEnumerable&lt;TCollection&gt; sources) where TCollection : System.Collections.Generic.IEnumerable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Concat&lt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt;) TCollection, T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt; sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Concat``2(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("concat")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="sources" Type="System.Collections.Generic.IEnumerable&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="sources">The input enumeration-of-enumerations.</param>
        <summary>Combines the given enumeration-of-enumerations as a single concatenated
 enumeration.</summary>
        <returns>The result sequence.</returns>
        <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;T&gt; (T value, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool Contains&lt;T&gt;(!!T value, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Contains``1(``0,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("contains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The value to locate in the input sequence.</param>
        <param name="source">The input sequence.</param>
        <summary>Tests if the sequence contains the specified element.</summary>
        <returns>True if the input sequence contains the specified element; false otherwise.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CountBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Tuple&lt;TKey,int&gt;&gt; CountBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;class System.Tuple`2&lt;!!TKey, int32&gt;&gt; CountBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.CountBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("countBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Tuple&lt;TKey,System.Int32&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">A function transforming each item of the input sequence into a key to be
 compared against the others.</param>
        <param name="source">The input sequence.</param>
        <summary>Applies a key-generating function to each element of a sequence and returns a sequence yielding unique
 keys and their number of occurrences in the original sequence.</summary>
        <returns>The result sequence.</returns>
        <remarks>Note that this function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delay&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Delay&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable&lt;T&gt;&gt; generator);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Delay&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt;&gt; generator) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Delay``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable{``0}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("delay")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="generator" Type="Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,System.Collections.Generic.IEnumerable&lt;T&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="generator">The generating function for the sequence.</param>
        <summary>Returns a sequence that is built from the given delayed specification of a
 sequence.</summary>
        <returns>To be added.</returns>
        <remarks>The input function is evaluated each time an IEnumerator for the sequence 
 is requested.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Distinct&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Distinct&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Distinct``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("distinct")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns a sequence that contains no duplicate entries according to generic hash and
 equality comparisons on the entries.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="DistinctBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; DistinctBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; DistinctBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.DistinctBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("distinctBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">A function transforming the sequence items into comparable keys.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns a sequence that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the sequence then the later occurrences are discarded.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Empty``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("empty")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.GeneralizableValue</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Creates an empty sequence.</summary>
        <returns>An empty sequence.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExactlyOne&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ExactlyOne&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T ExactlyOne&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.ExactlyOne``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exactlyOne")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns the only element of the sequence.</summary>
        <returns>The only element of the sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input does not have precisely one element.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Except&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; itemsToExclude, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Except&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; itemsToExclude, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("except")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="itemsToExclude" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="itemsToExclude">A sequence whose elements that also occur in the second sequence will cause those elements to be
 removed from the returned sequence.</param>
        <param name="source">A sequence whose elements that are not also in first will be returned.</param>
        <summary>Returns a new sequence with the distinct elements of the second sequence which do not appear in the first sequence,
 using generic hash and equality comparisons to compare values.</summary>
        <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
        <remarks>Note that this function returns a sequence that digests the whole of the first input sequence as soon as
 the result sequence is iterated. As a result this function should not be used with
 large or infinite sequences in the first parameter. The function makes no assumption on the ordering of the first input
 sequence.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the two input sequences is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool Exists&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exists")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function to test each item of the input sequence.</param>
        <param name="source">The input sequence.</param>
        <summary>Tests if any element of the sequence satisfies the given predicate.</summary>
        <returns>True if any result from the predicate is true; false otherwise.</returns>
        <remarks>The predicate is applied to the elements of the input sequence. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,bool&gt;&gt; predicate, System.Collections.Generic.IEnumerable&lt;T1&gt; source1, System.Collections.Generic.IEnumerable&lt;T2&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool Exists2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, bool&gt;&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T1&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!T2&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exists2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,System.Boolean&gt;&gt;" />
        <Parameter Name="source1" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="predicate">A function to test each pair of items from the input sequences.</param>
        <param name="source1">The first input sequence.</param>
        <param name="source2">The second input sequence.</param>
        <summary>Tests if any pair of corresponding elements of the input sequences satisfies the given predicate.</summary>
        <returns>True if any result from the predicate is true; false otherwise.</returns>
        <remarks>The predicate is applied to matching elements in the two sequences up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, false is returned. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the two input sequences is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Filter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Filter&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Filter&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function to test whether each item in the input sequence should be included in the output.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true". This is a synonym for Seq.where.</summary>
        <returns>The result sequence.</returns>
        <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.

 Remember sequence is lazy, effects are delayed until it is enumerated.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Find&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("find")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function to test whether an item in the sequence should be returned.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns the first element for which the given function returns True.</summary>
        <returns>The first element for which the predicate returns True.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if no element returns true when
 evaluated by the predicate</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null</exception>
      </Docs>
    </Member>
    <Member MemberName="FindBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T FindBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.FindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("findBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function to test whether an item in the sequence should be returned.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns the last element for which the given function returns True.</summary>
        <returns>The last element for which the predicate returns True.</returns>
        <remarks>This function digests the whole initial sequence as soon as it is called. As a
 result this function should not be used with large or infinite sequences.</remarks>
        <remarks>This function consumes the whole input sequence before returning the result.</remarks>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if no element returns true when
 evaluated by the predicate</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FindIndex&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("findIndex")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function to test whether the index of a particular element should be returned.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns the index of the first element for which the given function returns True.</summary>
        <returns>The index of the first element for which the predicate returns True.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if no element returns true when
 evaluated by the predicate</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndexBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndexBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FindIndexBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.FindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("findIndexBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function to test whether the index of a particular element should be returned.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns the index of the last element for which the given function returns True.</summary>
        <returns>The index of the last element for which the predicate returns True.</returns>
        <remarks>This function digests the whole initial sequence as soon as it is called. As a
 result this function should not be used with large or infinite sequences.</remarks>
        <remarks>This function consumes the whole input sequence before returning the result.</remarks>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if no element returns true when
 evaluated by the predicate</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null</exception>
      </Docs>
    </Member>
    <Member MemberName="Fold&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState Fold&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt; folder, TState state, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState Fold&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TState&gt;&gt; folder, !!TState state, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("fold")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">A function that updates the state with each element from the sequence.</param>
        <param name="state">The initial state.</param>
        <param name="source">The input sequence.</param>
        <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f s i0)...) iN</c></summary>
        <returns>The state object after the folding function is applied to each element of the sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fold2&lt;T1,T2,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState Fold2&lt;T1,T2,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TState&gt;&gt;&gt; folder, TState state, System.Collections.Generic.IEnumerable&lt;T1&gt; source1, System.Collections.Generic.IEnumerable&lt;T2&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState Fold2&lt;T1, T2, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TState&gt;&gt;&gt; folder, !!TState state, class System.Collections.Generic.IEnumerable`1&lt;!!T1&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!T2&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``2,System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("fold2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TState&gt;&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="source1" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="state">The initial state.</param>
        <param name="source1">The first input sequence.</param>
        <param name="source2">The second input sequence.</param>
        <summary>Applies a function to corresponding elements of two collections, threading an accumulator argument
 through the computation. The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other sequence are ignored.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jN</c>
 then computes <c>f (... (f s i0 j0)...) iN jN</c>.</summary>
        <returns>The final state value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the either of the input sequences is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FoldBack&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState FoldBack&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt; folder, System.Collections.Generic.IEnumerable&lt;T&gt; source, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState FoldBack&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, !!TState&gt;&gt; folder, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.IEnumerable{``0},``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("foldBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="source">The input sequence.</param>
        <param name="state">The initial state.</param>
        <summary>Applies a function to each element of the collection, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c>
 then computes <c>f i0 (... (f iN s)...)</c></summary>
        <returns>The state object after the folding function is applied to each element of the sequence.</returns>
        <remarks>This function consumes the whole input sequence before returning the result.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FoldBack2&lt;T1,T2,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState FoldBack2&lt;T1,T2,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;&gt; folder, System.Collections.Generic.IEnumerable&lt;T1&gt; source1, System.Collections.Generic.IEnumerable&lt;T2&gt; source2, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState FoldBack2&lt;T1, T2, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, !!TState&gt;&gt;&gt; folder, class System.Collections.Generic.IEnumerable`1&lt;!!T1&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!T2&gt; source2, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},``2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("foldBack2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;&gt;" />
        <Parameter Name="source1" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="source1">The first input sequence.</param>
        <param name="source2">The second input sequence.</param>
        <param name="state">The initial state.</param>
        <summary>Applies a function to corresponding elements of two collections, starting from the end of the shorter collection,
 threading an accumulator argument through the computation. The two sequences need not have equal lengths.
 If the input function is <c>f</c> and the elements are <c>i0...iN</c> and <c>j0...jM</c>, N &lt; M
 then computes <c>f i0 j0 (... (f iN jN s)...)</c>.</summary>
        <returns>The final state value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the either of the input sequences is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool ForAll&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("forall")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function to test an element of the input sequence.</param>
        <param name="source">The input sequence.</param>
        <summary>Tests if all elements of the sequence satisfy the given predicate.</summary>
        <returns>True if every element of the sequence satisfies the predicate; false otherwise.</returns>
        <remarks>The predicate is applied to the elements of the input sequence. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForAll2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,bool&gt;&gt; predicate, System.Collections.Generic.IEnumerable&lt;T1&gt; source1, System.Collections.Generic.IEnumerable&lt;T2&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool ForAll2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, bool&gt;&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T1&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!T2&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("forall2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,System.Boolean&gt;&gt;" />
        <Parameter Name="source1" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="predicate">A function to test pairs of elements from the input sequences.</param>
        <param name="source1">The first input sequence.</param>
        <param name="source2">The second input sequence.</param>
        <summary>Tests the all pairs of elements drawn from the two sequences satisfy the
 given predicate. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.</summary>
        <returns>True if all pairs satisfy the predicate; false otherwise.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Get&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Get&lt;T&gt; (int index, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Get&lt;T&gt;(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Get``1(System.Int32,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("nth")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("please use Seq.item")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="index">The index of element to retrieve.</param>
        <param name="source">The input sequence.</param>
        <summary>Computes the nth element in the collection.</summary>
        <returns>The nth element of the sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the index is negative or the input sequence does not contain enough elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Tuple&lt;TKey,System.Collections.Generic.IEnumerable&lt;T&gt;&gt;&gt; GroupBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;class System.Tuple`2&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt;&gt;&gt; GroupBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.GroupBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("groupBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Tuple&lt;TKey,System.Collections.Generic.IEnumerable&lt;T&gt;&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">A function that transforms an element of the sequence into a comparable key.</param>
        <param name="source">The input sequence.</param>
        <summary>Applies a key-generating function to each element of a sequence and yields a sequence of 
 unique keys. Each unique key contains a sequence of all elements that match 
 to this key.</summary>
        <returns>The result sequence.</returns>
        <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Head&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Head&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Head&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Head``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("head")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns the first element of the sequence.</summary>
        <returns>The first element of the sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input does not have any elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Indexed&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Tuple&lt;int,T&gt;&gt; Indexed&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;class System.Tuple`2&lt;int32, !!T&gt;&gt; Indexed&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Indexed``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("indexed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Tuple&lt;System.Int32,T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Builds a new collection whose elements are the corresponding elements of the input collection
 paired with the integer index (from 0) of each element.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Initialize&lt;T&gt; (int count, Microsoft.FSharp.Core.FSharpFunc&lt;int,T&gt; initializer);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Initialize&lt;T&gt;(int32 count, class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, !!T&gt; initializer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("init")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="initializer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The maximum number of items to generate for the sequence.</param>
        <param name="initializer">A function that generates an item in the sequence from a given index.</param>
        <summary>Generates a new sequence which, when iterated, will return successive
 elements by calling the given function, up to the given count.  Each element is saved after its
 initialization.  The function is passed the index of the item being
 generated.</summary>
        <returns>The result sequence.</returns>
        <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>
        <exception cref="System.ArgumentException">Thrown when count is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="InitializeInfinite&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; InitializeInfinite&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,T&gt; initializer);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; InitializeInfinite&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, !!T&gt; initializer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.InitializeInfinite``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("initInfinite")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="initializer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="initializer">A function that generates an item in the sequence from a given index.</param>
        <summary>Generates a new sequence which, when iterated, will return successive
 elements by calling the given function.  The results of calling the function
 will not be saved, that is the function will be reapplied as necessary to
 regenerate the elements.  The function is passed the index of the item being
 generated.</summary>
        <returns>The result sequence.</returns>
        <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.
 Iteration can continue up to <c>Int32.MaxValue</c>.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsEmpty&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool IsEmpty&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("isEmpty")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns true if the sequence contains no elements, false otherwise.</summary>
        <returns>True if the sequence is empty; false otherwise.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Item&lt;T&gt; (int index, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Item&lt;T&gt;(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Item``1(System.Int32,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("item")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="index">The index of the element to retrieve.</param>
        <param name="source">The input sequence.</param>
        <summary>Computes the element at the specified index in the collection.</summary>
        <returns>The element at the specified index of the sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the index is negative or the input sequence does not contain enough elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Iterate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Iterate&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt; action, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Iterate&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.Unit&gt; action, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="action">A function to apply to each element of the sequence.</param>
        <param name="source">The input sequence.</param>
        <summary>Applies the given function to each element of the collection.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Iterate2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static void Iterate2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt; action, System.Collections.Generic.IEnumerable&lt;T1&gt; source1, System.Collections.Generic.IEnumerable&lt;T2&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Iterate2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.Unit&gt;&gt; action, class System.Collections.Generic.IEnumerable`1&lt;!!T1&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!T2&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iter2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt;" />
        <Parameter Name="source1" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="action">A function to apply to each pair of elements from the input sequences.</param>
        <param name="source1">The first input sequence.</param>
        <param name="source2">The second input sequence.</param>
        <summary>Applies the given function to two collections simultaneously. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="IterateIndexed&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IterateIndexed&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;&gt; action, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static void IterateIndexed&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.Unit&gt;&gt; action, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iteri")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="action">A function to apply to each element of the sequence that can also access the current index.</param>
        <param name="source">The input sequence.</param>
        <summary>Applies the given function to each element of the collection. The integer passed to the
 function indicates the index of element.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="IterateIndexed2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static void IterateIndexed2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt;&gt; action, System.Collections.Generic.IEnumerable&lt;T1&gt; source1, System.Collections.Generic.IEnumerable&lt;T2&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static void IterateIndexed2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.Unit&gt;&gt;&gt; action, class System.Collections.Generic.IEnumerable`1&lt;!!T1&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!T2&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iteri2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt;&gt;" />
        <Parameter Name="source1" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="action">A function to apply to each pair of elements from the input sequences along with their index.</param>
        <param name="source1">The first input sequence.</param>
        <param name="source2">The second input sequence.</param>
        <summary>Applies the given function to two collections simultaneously. If one sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored. The integer passed to the
 function indicates the index of element.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Last&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Last&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Last``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("last")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns the last element of the sequence.</summary>
        <returns>The last element of the sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input does not have any elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int Length&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Length&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Length``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("length")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns the length of the sequence</summary>
        <returns>The length of the sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Map&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Map&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; mapping, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Map&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; mapping, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("map")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">A function to transform items from the input sequence.</param>
        <param name="source">The input sequence.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection.  The given function will be applied
 as elements are demanded using the <c>MoveNext</c> method on enumerators retrieved from the
 object.</summary>
        <returns>The result sequence.</returns>
        <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Map2&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Map2&lt;T1,T2,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt; mapping, System.Collections.Generic.IEnumerable&lt;T1&gt; source1, System.Collections.Generic.IEnumerable&lt;T2&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Map2&lt;T1, T2, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TResult&gt;&gt; mapping, class System.Collections.Generic.IEnumerable`1&lt;!!T1&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!T2&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("map2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;" />
        <Parameter Name="source1" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">A function to transform pairs of items from the input sequences.</param>
        <param name="source1">The first input sequence.</param>
        <param name="source2">The second input sequence.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Map3&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Map3&lt;T1,T2,T3,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt; mapping, System.Collections.Generic.IEnumerable&lt;T1&gt; source1, System.Collections.Generic.IEnumerable&lt;T2&gt; source2, System.Collections.Generic.IEnumerable&lt;T3&gt; source3);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Map3&lt;T1, T2, T3, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T3, !!TResult&gt;&gt;&gt; mapping, class System.Collections.Generic.IEnumerable`1&lt;!!T1&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!T2&gt; source2, class System.Collections.Generic.IEnumerable`1&lt;!!T3&gt; source3) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("map3")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt;" />
        <Parameter Name="source1" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
        <Parameter Name="source3" Type="System.Collections.Generic.IEnumerable&lt;T3&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform triples of elements from the input sequences.</param>
        <param name="source1">The first input sequence.</param>
        <param name="source2">The second input sequence.</param>
        <param name="source3">The third input sequence.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding triples of elements from the three sequences. If one input sequence if shorter than
 the others then the remaining elements of the longer sequences are ignored.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when any of the input sequences is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapFold&lt;T,TState,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;System.Collections.Generic.IEnumerable&lt;TResult&gt;,TState&gt; MapFold&lt;T,TState,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,Tuple&lt;TResult,TState&gt;&gt;&gt; mapping, TState state, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;, !!TState&gt; MapFold&lt;T, TState, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class System.Tuple`2&lt;!!TResult, !!TState&gt;&gt;&gt; mapping, !!TState state, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.MapFold``3(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``2,``1}}},``1,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapFold")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;System.Collections.Generic.IEnumerable&lt;TResult&gt;,TState&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Tuple&lt;TResult,TState&gt;&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform elements from the input collection and accumulate the final value.</param>
        <param name="state">The initial state.</param>
        <param name="source">To be added.</param>
        <summary>Combines map and fold. Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The function is also used to accumulate a final value.</summary>
        <returns>The collection of transformed elements, and the final accumulated value.</returns>
        <remarks>This function digests the whole initial sequence as soon as it is called. As a result this function should
 not be used with large or infinite sequences.</remarks>
        <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapFoldBack&lt;T,TState,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;System.Collections.Generic.IEnumerable&lt;TResult&gt;,TState&gt; MapFoldBack&lt;T,TState,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,Tuple&lt;TResult,TState&gt;&gt;&gt; mapping, System.Collections.Generic.IEnumerable&lt;T&gt; source, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;, !!TState&gt; MapFoldBack&lt;T, TState, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class System.Tuple`2&lt;!!TResult, !!TState&gt;&gt;&gt; mapping, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.MapFoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},System.Collections.Generic.IEnumerable{``0},``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapFoldBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;System.Collections.Generic.IEnumerable&lt;TResult&gt;,TState&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,System.Tuple&lt;TResult,TState&gt;&gt;&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform elements from the input collection and accumulate the final value.</param>
        <param name="source">To be added.</param>
        <param name="state">The initial state.</param>
        <summary>Combines map and foldBack. Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The function is also used to accumulate a final value.</summary>
        <returns>The collection of transformed elements, and the final accumulated value.</returns>
        <remarks>This function digests the whole initial sequence as soon as it is called. As a result this function should
 not be used with large or infinite sequences.</remarks>
        <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input collection is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapIndexed&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; MapIndexed&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;&gt; mapping, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; MapIndexed&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt;&gt; mapping, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapi")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">A function to transform items from the input sequence that also supplies the current index.</param>
        <param name="source">The input sequence.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to each of the elements of the collection. The integer index passed to the
 function indicates the index (from 0) of element being transformed.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapIndexed2&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; MapIndexed2&lt;T1,T2,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;&gt; mapping, System.Collections.Generic.IEnumerable&lt;T1&gt; source1, System.Collections.Generic.IEnumerable&lt;T2&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; MapIndexed2&lt;T1, T2, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TResult&gt;&gt;&gt; mapping, class System.Collections.Generic.IEnumerable`1&lt;!!T1&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!T2&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapi2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;&gt;" />
        <Parameter Name="source1" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">A function to transform pairs of items from the input sequences that also supplies the current index.</param>
        <param name="source1">The first input sequence.</param>
        <param name="source2">The second input sequence.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than 
 the other then the remaining elements of the longer sequence are ignored. The integer index passed to the
 function indicates the index (from 0) of element being transformed.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Max&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Max&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Max``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("max")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns the greatest of all elements of the sequence, compared via Operators.max</summary>
        <returns>The largest element of the sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static T MaxBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T MaxBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("maxBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">A function to transform items from the input sequence into comparable keys.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns the greatest of all elements of the sequence, compared via Operators.max on the function result.</summary>
        <returns>The largest element of the sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Min&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Min&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Min``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("min")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns the lowest of all elements of the sequence, compared via <c>Operators.min</c>.</summary>
        <returns>The smallest element of the sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static T MinBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T MinBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("minBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">A function to transform items from the input sequence into comparable keys.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns the lowest of all elements of the sequence, compared via Operators.min on the function result.</summary>
        <returns>The smallest element of the sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; OfArray&lt;T&gt; (T[] source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; OfArray&lt;T&gt;(!!T[] source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.OfArray``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("ofArray")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input array.</param>
        <summary>Views the given array as a sequence.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfList&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; OfList&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; OfList&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("ofList")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input list.</param>
        <summary>Views the given list as a sequence.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pairwise&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Tuple&lt;T,T&gt;&gt; Pairwise&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;class System.Tuple`2&lt;!!T, !!T&gt;&gt; Pairwise&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Pairwise``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("pairwise")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Tuple&lt;T,T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns a sequence of each element in the input sequence and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Permute&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Permute&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,int&gt; indexMap, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Permute&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, int32&gt; indexMap, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Permute``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("permute")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="indexMap" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,System.Int32&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="indexMap">The function that maps input indices to output indices.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns a sequence with all elements permuted according to the
 specified permutation.</summary>
        <returns>The result sequence.</returns>
        <remarks>Note that this function returns a sequence that digests the whole initial sequence as soon as
 that sequence is iterated. As a result this function should not be used with
 large or infinite sequences.</remarks>
        <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when indexMap does not produce a valid permutation.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pick&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Pick&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt; chooser, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult Pick&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt;&gt; chooser, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("pick")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chooser" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="chooser">A function to transform each item of the input sequence into an option of the output type.</param>
        <param name="source">The input sequence.</param>
        <summary>Applies the given function to successive elements, returning the first
 <c>x</c> where the function returns "Some(x)".</summary>
        <returns>The selected element.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown when every item of the sequence
 evaluates to <c>None</c> when the given function is applied.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; ReadOnly&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; ReadOnly&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.ReadOnly``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("readonly")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Builds a new sequence object that delegates to the given sequence object. This ensures 
 the original sequence cannot be rediscovered and mutated by a type cast. For example, 
 if given an array the returned sequence will return the elements of the array, but
 you cannot cast the returned sequence object to an array.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Reduce&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt; reduction, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Reduce&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!T&gt;&gt; reduction, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("reduce")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reduction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="reduction">A function that takes in the current accumulated result and the next
 element of the sequence to produce the next accumulated result.</param>
        <param name="source">The input sequence.</param>
        <summary>Applies a function to each element of the sequence, threading an accumulator argument
 through the computation. Begin by applying the function to the first two elements.
 Then feed this result into the function along with the third element and so on.  
 Return the final result.</summary>
        <returns>The final result of the reduction function.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReduceBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ReduceBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt; reduction, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T ReduceBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!T&gt;&gt; reduction, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("reduceBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reduction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="reduction">A function that takes in the next-to-last element of the sequence and the
 current accumulated result to produce the next accumulated result.</param>
        <param name="source">The input sequence.</param>
        <summary>Applies a function to each element of the sequence, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f i0 (...(f iN-1 iN))</c>.</summary>
        <returns>The final result of the reductions.</returns>
        <remarks>This function consumes the whole input sequence before returning the result.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replicate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Replicate&lt;T&gt; (int count, T initial);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Replicate&lt;T&gt;(int32 count, !!T initial) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Replicate``1(System.Int32,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("replicate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="initial" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The number of elements to replicate.</param>
        <param name="initial">The value to replicate</param>
        <summary>Creates a sequence by replicating the given initial value.</summary>
        <returns>The generated sequence.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Reverse&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Reverse&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Reverse``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("rev")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns a new sequence with the elements in reverse order.</summary>
        <returns>The reversed sequence.</returns>
        <remarks>This function consumes the whole input sequence before yielding the first element of the reversed sequence.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scan&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TState&gt; Scan&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt; folder, TState state, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!TState&gt; Scan&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TState&gt;&gt; folder, !!TState state, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("scan")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TState&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">A function that updates the state with each element from the sequence.</param>
        <param name="state">The initial state.</param>
        <param name="source">The input sequence.</param>
        <summary>Like fold, but computes on-demand and returns the sequence of intermediary and final results.</summary>
        <returns>The resulting sequence of computed states.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScanBack&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TState&gt; ScanBack&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt; folder, System.Collections.Generic.IEnumerable&lt;T&gt; source, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!TState&gt; ScanBack&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, !!TState&gt;&gt; folder, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Collections.Generic.IEnumerable{``0},``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("scanBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TState&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">A function that updates the state with each element from the sequence.</param>
        <param name="source">The input sequence.</param>
        <param name="state">The initial state.</param>
        <summary>Like <c>foldBack</c>, but returns the sequence of intermediary and final results.</summary>
        <returns>The resulting sequence of computed states.</returns>
        <remarks>This function returns a sequence that digests the whole initial sequence as soon as that
 sequence is iterated. As a result this function should not be used with large or infinite sequences.
 </remarks>
        <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Singleton&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Singleton&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Singleton&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Singleton``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("singleton")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input item.</param>
        <summary>Returns a sequence that yields one item only.</summary>
        <returns>The result sequence of one item.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Skip&lt;T&gt; (int count, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Skip&lt;T&gt;(int32 count, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Skip``1(System.Int32,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("skip")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The number of items to skip.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns a sequence that skips N elements of the underlying sequence and then yields the
 remaining elements of the sequence.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the sequence.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; SkipWhile&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; SkipWhile&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.SkipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("skipWhile")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function that evaluates an element of the sequence to a boolean value.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns a sequence that, when iterated, skips elements of the underlying sequence while the 
 given predicate returns True, and then yields the remaining elements of the sequence.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Sort&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Sort&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Sort``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sort")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Yields a sequence ordered by keys.</summary>
        <returns>The result sequence.</returns>
        <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>
        <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; SortBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; SortBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">A function to transform items of the input sequence into comparable keys.</param>
        <param name="source">The input sequence.</param>
        <summary>Applies a key-generating function to each element of a sequence and yield a sequence ordered
 by keys.  The keys are compared using generic comparison as implemented by <c>Operators.compare</c>.</summary>
        <returns>The result sequence.</returns>
        <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortByDescending&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; SortByDescending&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; SortByDescending&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.SortByDescending``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortByDescending")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">A function to transform items of the input sequence into comparable keys.</param>
        <param name="source">The input sequence.</param>
        <summary>Applies a key-generating function to each element of a sequence and yield a sequence ordered
 descending by keys.  The keys are compared using generic comparison as implemented by <c>Operators.compare</c>.</summary>
        <returns>The result sequence.</returns>
        <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortDescending&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; SortDescending&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; SortDescending&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.SortDescending``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortDescending")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Yields a sequence ordered descending by keys.</summary>
        <returns>The result sequence.</returns>
        <remarks>This function returns a sequence that digests the whole initial sequence as soon as 
 that sequence is iterated. As a result this function should not be used with 
 large or infinite sequences. The function makes no assumption on the ordering of the original 
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; SortWith&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,int&gt;&gt; comparer, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; SortWith&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, int32&gt;&gt; comparer, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.SortWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortWith")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Int32&gt;&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="comparer">The function to compare the collection elements.</param>
        <param name="source">To be added.</param>
        <summary>Yields a sequence ordered using the given comparison function.</summary>
        <returns>The result sequence.</returns>
        <remarks>This function returns a sequence that digests the whole initial sequence as soon as
 that sequence is iterated. As a result this function should not be used with
 large or infinite sequences. The function makes no assumption on the ordering of the original
 sequence.

 This is a stable sort, that is the original order of equal elements is preserved.</remarks>
        <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SplitInto&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T[]&gt; SplitInto&lt;T&gt; (int count, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T[]&gt; SplitInto&lt;T&gt;(int32 count, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.SplitInto``1(System.Int32,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("splitInto")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The maximum number of chunks.</param>
        <param name="source">The input sequence.</param>
        <summary>Splits the input sequence into at most <c>count</c> chunks.</summary>
        <returns>The sequence split into chunks.</returns>
        <remarks>This function returns a sequence that digests the whole initial sequence as soon as that
 sequence is iterated. As a result this function should not be used with large or infinite sequences.</remarks>
        <remarks>This function consumes the whole input sequence before yielding the first element of the result sequence.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when <c>count</c> is not positive.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sum&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Sum&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Sum``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sum")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns the sum of the elements in the sequence.</summary>
        <returns>The computed sum.</returns>
        <remarks>The elements are summed using the <c>+</c> operator and <c>Zero</c> property associated with the generated type.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SumBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult SumBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult SumBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sumBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">A function to transform items from the input sequence into the type that will be summed.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns the sum of the results generated by applying the function to each element of the sequence.</summary>
        <returns>The computed sum.</returns>
        <remarks>The generated elements are summed using the <c>+</c> operator and <c>Zero</c> property associated with the generated type.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tail&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Tail&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Tail&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Tail``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tail")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns a sequence that skips 1 element of the underlying sequence and then yields the
 remaining elements of the sequence.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.InvalidOperationException">Thrown when the input sequence is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Take&lt;T&gt; (int count, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Take&lt;T&gt;(int32 count, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Take``1(System.Int32,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("take")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The number of items to take.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns the first N elements of the sequence.</summary>
        <returns>The result sequence.</returns>
        <remarks>Throws <c>InvalidOperationException</c>
 if the count exceeds the number of elements in the sequence. <c>Seq.truncate</c>
 returns as many items as the sequence contains instead of throwing an exception.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input sequence is empty.</exception>
        <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the sequence.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; TakeWhile&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; TakeWhile&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.TakeWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("takeWhile")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function that evaluates to false when no more items should be returned.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns a sequence that, when iterated, yields elements of the underlying sequence while the 
 given predicate returns True, and then returns no further elements.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] ToArray&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] ToArray&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.ToArray``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("toArray")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Builds an array from the given collection.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; ToList&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; ToList&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.ToList``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("toList")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Builds a list from the given collection.</summary>
        <returns>The result list.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Truncate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Truncate&lt;T&gt; (int count, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Truncate&lt;T&gt;(int32 count, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Truncate``1(System.Int32,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("truncate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The maximum number of items to enumerate.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns a sequence that when enumerated returns at most N elements.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFind&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryFind&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryFind&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFind")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function that evaluates to a Boolean when given an item in the sequence.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns the first element for which the given function returns True.
 Return None if no such element exists.</summary>
        <returns>The found element or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFindBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryFindBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryFindBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.TryFindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFindBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function that evaluates to a Boolean when given an item in the sequence.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns the last element for which the given function returns True.
 Return None if no such element exists.</summary>
        <returns>The found element or None.</returns>
        <remarks>This function digests the whole initial sequence as soon as it is called. As a
 result this function should not be used with large or infinite sequences.</remarks>
        <remarks>This function consumes the whole input sequence before returning the result.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;int&gt; TryFindIndex&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; TryFindIndex&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFindIndex")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function that evaluates to a Boolean when given an item in the sequence.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns the index of the first element in the sequence 
 that satisfies the given predicate. Return <c>None</c> if no such element exists.</summary>
        <returns>The found index or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFindIndexBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;int&gt; TryFindIndexBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; TryFindIndexBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.TryFindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFindIndexBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function that evaluates to a Boolean when given an item in the sequence.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns the index of the last element in the sequence
 that satisfies the given predicate. Return <c>None</c> if no such element exists.</summary>
        <returns>The found index or <c>None</c>.</returns>
        <remarks>This function digests the whole initial sequence as soon as it is called. As a
 result this function should not be used with large or infinite sequences.</remarks>
        <remarks>This function consumes the whole input sequence before returning the result.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryHead&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryHead&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryHead&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.TryHead``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryHead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns the first element of the sequence, or None if the sequence is empty.</summary>
        <returns>The first element of the sequence or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryItem&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryItem&lt;T&gt; (int index, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryItem&lt;T&gt;(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.TryItem``1(System.Int32,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryItem")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="index">The index of element to retrieve.</param>
        <param name="source">The input sequence.</param>
        <summary>Tries to find the nth element in the sequence.
 Returns <c>None</c> if index is negative or the input sequence does not contain enough elements.</summary>
        <returns>The nth element of the sequence or <c>None</c>.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryLast&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryLast&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.TryLast``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryLast")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Returns the last element of the sequence.
 Return <c>None</c> if no such element exists.</summary>
        <returns>The last element of the sequence or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryPick&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt; TryPick&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt; chooser, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt; TryPick&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt;&gt; chooser, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryPick")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chooser" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="chooser">A function that transforms items from the input sequence into options.</param>
        <param name="source">The input sequence.</param>
        <summary>Applies the given function to successive elements, returning the first
 result where the function returns "Some(x)".</summary>
        <returns>The chosen element or <c>None</c>.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unfold&lt;TState,T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Unfold&lt;TState,T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpOption&lt;Tuple&lt;T,TState&gt;&gt;&gt; generator, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Unfold&lt;TState, T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpOption`1&lt;class System.Tuple`2&lt;!!T, !!TState&gt;&gt;&gt; generator, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``1,``0}}},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("unfold")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="generator" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpOption&lt;System.Tuple&lt;T,TState&gt;&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="generator">A function that takes in the current state and returns an option tuple of the next
 element of the sequence and the next state value.</param>
        <param name="state">The initial state value.</param>
        <summary>Returns a sequence that contains the elements generated by the given computation.
 The given initial <c>state</c> argument is passed to the element generator.
 For each IEnumerator elements in the stream are generated on-demand by applying the element
 generator, until a None value is returned by the element generator. Each call to the element
 generator returns a new residual <c>state</c>.</summary>
        <returns>The result sequence.</returns>
        <remarks>The stream will be recomputed each time an IEnumerator is requested and iterated for the Seq.

 The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; Where&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Where&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Where``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("where")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function to test whether each item in the input sequence should be included in the output.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true".</summary>
        <returns>The result sequence.</returns>
        <remarks>The returned sequence may be passed between threads safely. However, 
 individual IEnumerator values generated from the returned sequence should not be accessed concurrently.

 Remember sequence is lazy, effects are delayed until it is enumerated.
 
 A synonym for Seq.filter.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Windowed&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T[]&gt; Windowed&lt;T&gt; (int windowSize, System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T[]&gt; Windowed&lt;T&gt;(int32 windowSize, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Windowed``1(System.Int32,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("windowed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="windowSize" Type="System.Int32" />
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="windowSize">The number of elements in each window.</param>
        <param name="source">The input sequence.</param>
        <summary>Returns a sequence that yields sliding windows containing elements drawn from the input
 sequence. Each window is returned as a fresh array.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when windowSize is not positive.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Tuple&lt;T1,T2&gt;&gt; Zip&lt;T1,T2&gt; (System.Collections.Generic.IEnumerable&lt;T1&gt; source1, System.Collections.Generic.IEnumerable&lt;T2&gt; source2);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;class System.Tuple`2&lt;!!T1, !!T2&gt;&gt; Zip&lt;T1, T2&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T1&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!T2&gt; source2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("zip")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Tuple&lt;T1,T2&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="source1">The first input sequence.</param>
        <param name="source2">The second input sequence.</param>
        <summary>Combines the two sequences into a list of pairs. The two sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequence are ignored.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input sequences is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip3&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;Tuple&lt;T1,T2,T3&gt;&gt; Zip3&lt;T1,T2,T3&gt; (System.Collections.Generic.IEnumerable&lt;T1&gt; source1, System.Collections.Generic.IEnumerable&lt;T2&gt; source2, System.Collections.Generic.IEnumerable&lt;T3&gt; source3);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;class System.Tuple`3&lt;!!T1, !!T2, !!T3&gt;&gt; Zip3&lt;T1, T2, T3&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T1&gt; source1, class System.Collections.Generic.IEnumerable`1&lt;!!T2&gt; source2, class System.Collections.Generic.IEnumerable`1&lt;!!T3&gt; source3) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.SeqModule.Zip3``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("zip3")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Tuple&lt;T1,T2,T3&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source1" Type="System.Collections.Generic.IEnumerable&lt;T1&gt;" />
        <Parameter Name="source2" Type="System.Collections.Generic.IEnumerable&lt;T2&gt;" />
        <Parameter Name="source3" Type="System.Collections.Generic.IEnumerable&lt;T3&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="source1">The first input sequence.</param>
        <param name="source2">The second input sequence.</param>
        <param name="source3">The third input sequence.</param>
        <summary>Combines the three sequences into a list of triples. The sequences need not have equal lengths:
 when one sequence is exhausted any remaining elements in the other
 sequences are ignored.</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when any of the input sequences is null.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
