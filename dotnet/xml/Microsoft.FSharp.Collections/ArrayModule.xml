<Type Name="ArrayModule" FullName="Microsoft.FSharp.Collections.ArrayModule">
  <TypeSignature Language="C#" Value="public static class ArrayModule" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed ArrayModule extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.FSharp.Collections.ArrayModule" />
  <TypeSignature Language="VB.NET" Value="Public Class ArrayModule" />
  <TypeSignature Language="F#" Value="module Array" />
  <AssemblyInfo>
    <AssemblyName>FSharp.Core</AssemblyName>
    <AssemblyVersion>4.5.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationMapping(Microsoft.FSharp.Core.SourceConstructFlags.Module)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationRepresentation(Microsoft.FSharp.Core.CompilationRepresentationFlags.ModuleSuffix)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.RequireQualifiedAccess</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Basic operations on arrays.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AllPairs&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T1,T2&gt;[] AllPairs&lt;T1,T2&gt; (T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!T1, !!T2&gt;[] AllPairs&lt;T1, T2&gt;(!!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.AllPairs``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllPairs(Of T1, T2) (array1 As T1(), array2 As T2()) As Tuple(Of T1, T2)()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.allPairs : 'T1[] -&gt; 'T2[] -&gt; 'T1 * 'T2[]" Usage="Microsoft.FSharp.Collections.ArrayModule.AllPairs array1 array2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("allPairs")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T1,T2&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Returns a new array that contains all pairings of elements from the first and second arrays.</summary>
        <returns>The resulting array of pairs.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Append&lt;T&gt; (T[] array1, T[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Append&lt;T&gt;(!!T[] array1, !!T[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Append``1(``0[],``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Append(Of T) (array1 As T(), array2 As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.append : 'T[] -&gt; 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Append array1 array2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("append")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array1" Type="T[]" />
        <Parameter Name="array2" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Builds a new array that contains the elements of the first array followed by the elements of the second array.</summary>
        <returns>The resulting array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Average&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Average&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Average``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Average(Of T) (array As T()) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.average : 'T[] -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.Average array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("average")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the average of the elements in the array.</summary>
        <returns>The average of the elements in the array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when <c>array</c> is empty.</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="AverageBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult AverageBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult AverageBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.AverageBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AverageBy(Of T, TResult) (projection As FSharpFunc(Of T, TResult), array As T()) As TResult" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.averageBy : ('T -&gt; 'Result) -&gt; 'T[] -&gt; 'Result" Usage="Microsoft.FSharp.Collections.ArrayModule.AverageBy projection array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("averageBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">The function to transform the array elements before averaging.</param>
        <param name="array">The input array.</param>
        <summary>Returns the average of the elements generated by applying the function to each element of the array.</summary>
        <returns>The computed average.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when <c>array</c> is empty.</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult[] Choose&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt; chooser, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult[] Choose&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt;&gt; chooser, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Choose``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Choose(Of T, TResult) (chooser As FSharpFunc(Of T, FSharpOption(Of TResult)), array As T()) As TResult()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.choose : ('T -&gt; option&lt;'Result&gt;) -&gt; 'T[] -&gt; 'Result[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Choose chooser array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("choose")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chooser" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="chooser">The function to generate options from the elements.</param>
        <param name="array">The input array.</param>
        <summary>Applies the given function to each element of the array. Returns
 the array comprised of the results "x" for each element where
 the function returns Some(x)</summary>
        <returns>The array of results.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ChunkBySize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[][] ChunkBySize&lt;T&gt; (int chunkSize, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[][] ChunkBySize&lt;T&gt;(int32 chunkSize, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ChunkBySize``1(System.Int32,``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ChunkBySize(Of T) (chunkSize As Integer, array As T()) As T()()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.chunkBySize : int -&gt; 'T[] -&gt; 'T[][]" Usage="Microsoft.FSharp.Collections.ArrayModule.ChunkBySize chunkSize array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("chunkBySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[][]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chunkSize" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="chunkSize">The maximum size of each chunk.</param>
        <param name="array">The input array.</param>
        <summary>Divides the input array into chunks of size at most <c>chunkSize</c>.</summary>
        <returns>The array divided into chunks.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when <c>chunkSize</c> is not positive.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult[] Collect&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult[]&gt; mapping, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult[] Collect&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult[]&gt; mapping, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Collect``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1[]},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Collect(Of T, TResult) (mapping As FSharpFunc(Of T, TResult()), array As T()) As TResult()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.collect : ('T -&gt; 'Result[]) -&gt; 'T[] -&gt; 'Result[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Collect mapping array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("collect")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult[]&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to create sub-arrays from the input array elements.</param>
        <param name="array">The input array.</param>
        <summary>For each element of the array, applies the given function. Concatenates all the results and return the combined array.</summary>
        <returns>The concatenation of the sub-arrays.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CompareWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int CompareWith&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,int&gt;&gt; comparer, T[] array1, T[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 CompareWith&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, int32&gt;&gt; comparer, !!T[] array1, !!T[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.CompareWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},``0[],``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareWith(Of T) (comparer As FSharpFunc(Of T, FSharpFunc(Of T, Integer)), array1 As T(), array2 As T()) As Integer" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.compareWith : ('T -&gt; 'T -&gt; int) -&gt; 'T[] -&gt; 'T[] -&gt; int" Usage="Microsoft.FSharp.Collections.ArrayModule.CompareWith comparer array1 array2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("compareWith")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Int32&gt;&gt;" />
        <Parameter Name="array1" Type="T[]" />
        <Parameter Name="array2" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="comparer">A function that takes an element from each array and returns an int.
 If it evaluates to a non-zero value iteration is stopped and that value is returned.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Compares two arrays using the given comparison function, element by element.</summary>
        <returns>Returns the first non-zero result from the comparison function. If the first array has 
 a larger element, the return value is always positive. If the second array has a larger 
 element, the return value is always negative. When the elements are equal in the two 
 arrays, 1 is returned if the first array is longer, 0 is returned if they are equal in 
 length, and -1 is returned when the second array is longer.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays
 is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T[]&gt; arrays);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T[]&gt; arrays) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Concat``1(System.Collections.Generic.IEnumerable{``0[]})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (arrays As IEnumerable(Of T())) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.concat : seq&lt;'T[]&gt; -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Concat arrays" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("concat")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arrays" Type="System.Collections.Generic.IEnumerable&lt;T[]&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="arrays">The input sequence of arrays.</param>
        <summary>Builds a new array that contains the elements of each of the given sequence of arrays.</summary>
        <returns>The concatenation of the sequence of input arrays.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;T&gt; (T value, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool Contains&lt;T&gt;(!!T value, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Contains``1(``0,``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Contains(Of T) (value As T, array As T()) As Boolean" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.contains : 'T -&gt; 'T[] -&gt; bool" Usage="Microsoft.FSharp.Collections.ArrayModule.Contains value array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("contains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The value to locate in the input array.</param>
        <param name="array">The input array.</param>
        <summary>Tests if the array contains the specified element.</summary>
        <returns>True if the input array contains the specified element; false otherwise.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Copy&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Copy&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Copy``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy(Of T) (array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.copy : 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Copy array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("copy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Builds a new array that contains the elements of the given array.</summary>
        <returns>A copy of the input array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopyTo&lt;T&gt; (T[] source, int sourceIndex, T[] target, int targetIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static void CopyTo&lt;T&gt;(!!T[] source, int32 sourceIndex, !!T[] target, int32 targetIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.CopyTo``1(``0[],System.Int32,``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyTo(Of T) (source As T(), sourceIndex As Integer, target As T(), targetIndex As Integer, count As Integer)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.blit : 'T[] -&gt; int -&gt; 'T[] -&gt; int -&gt; int -&gt; unit" Usage="Microsoft.FSharp.Collections.ArrayModule.CopyTo source sourceIndex target targetIndex count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("blit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T[]" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="target" Type="T[]" />
        <Parameter Name="targetIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The source array.</param>
        <param name="sourceIndex">The starting index of the source array.</param>
        <param name="target">The target array.</param>
        <param name="targetIndex">The starting index of the target array.</param>
        <param name="count">The number of elements to copy.</param>
        <summary>Reads a range of elements from the first array and write them into the second.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when any of sourceIndex, targetIndex or count are negative,
 or when there aren't enough elements in source or target.</exception>
      </Docs>
    </Member>
    <Member MemberName="CountBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;TKey,int&gt;[] CountBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!TKey, int32&gt;[] CountBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.CountBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CountBy(Of T, TKey) (projection As FSharpFunc(Of T, TKey), array As T()) As Tuple(Of TKey, Integer)()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.countBy : ('T -&gt; 'Key) -&gt; 'T[] -&gt; 'Key * int[]" Usage="Microsoft.FSharp.Collections.ArrayModule.CountBy projection array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("countBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;TKey,System.Int32&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">A function transforming each item of the input array into a key to be
 compared against the others.</param>
        <param name="array">The input array.</param>
        <summary>Applies a key-generating function to each element of an array and returns an array yielding unique
 keys and their number of occurrences in the original array.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Create&lt;T&gt; (int count, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Create&lt;T&gt;(int32 count, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Create``1(System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of T) (count As Integer, value As T) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.create : int -&gt; 'T -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Create count value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("create")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The length of the array to create.</param>
        <param name="value">The value for the elements.</param>
        <summary>Creates an array whose elements are all initially the given value.</summary>
        <returns>The created array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when count is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Distinct&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Distinct&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Distinct``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Distinct(Of T) (array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.distinct : 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Distinct array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("distinct")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns an array that contains no duplicate entries according to generic hash and
 equality comparisons on the entries.
 If an element occurs multiple times in the array then the later occurrences are discarded.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="DistinctBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static T[] DistinctBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] DistinctBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.DistinctBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DistinctBy(Of T, TKey) (projection As FSharpFunc(Of T, TKey), array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.distinctBy : ('T -&gt; 'Key) -&gt; 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.DistinctBy projection array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("distinctBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">A function transforming the array items into comparable keys.</param>
        <param name="array">The input array.</param>
        <summary>Returns an array that contains no duplicate entries according to the 
 generic hash and equality comparisons on the keys returned by the given key-generating function.
 If an element occurs multiple times in the array then the later occurrences are discarded.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.empty : unit -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("empty")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.GeneralizableValue</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Returns an empty array of the given type.</summary>
        <returns>The empty array.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExactlyOne&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ExactlyOne&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T ExactlyOne&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ExactlyOne``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExactlyOne(Of T) (array As T()) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.exactlyOne : 'T[] -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.ExactlyOne array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exactlyOne")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the only element of the array.</summary>
        <returns>The only element of the array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input does not have precisely one element.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Except&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; itemsToExclude, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Except&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; itemsToExclude, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Except``1(System.Collections.Generic.IEnumerable{``0},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Except(Of T) (itemsToExclude As IEnumerable(Of T), array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.except : seq&lt;'T&gt; -&gt; 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Except itemsToExclude array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("except")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="itemsToExclude" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="itemsToExclude">A sequence whose elements that also occur in the input array will cause those elements to be
 removed from the result.</param>
        <param name="array">An array whose elements that are not also in itemsToExclude will be returned.</param>
        <summary>Returns a new list with the distinct elements of the input array which do not appear in the itemsToExclude sequence,
 using generic hash and equality comparisons to compare values.</summary>
        <returns>An array that contains the distinct elements of <c>array</c> that do not appear in <c>itemsToExclude</c>.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either itemsToExclude or array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool Exists&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Exists``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As Boolean" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.exists : ('T -&gt; bool) -&gt; 'T[] -&gt; bool" Usage="Microsoft.FSharp.Collections.ArrayModule.Exists predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exists")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Tests if any element of the array satisfies the given predicate.</summary>
        <returns>True if any result from <c>predicate</c> is true.</returns>
        <remarks>The predicate is applied to the elements of the input array. If any application 
 returns true then the overall result is true and no further elements are tested. 
 Otherwise, false is returned.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,bool&gt;&gt; predicate, T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool Exists2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, bool&gt;&gt; predicate, !!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Exists2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists2(Of T1, T2) (predicate As FSharpFunc(Of T1, FSharpFunc(Of T2, Boolean)), array1 As T1(), array2 As T2()) As Boolean" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.exists2 : ('T1 -&gt; 'T2 -&gt; bool) -&gt; 'T1[] -&gt; 'T2[] -&gt; bool" Usage="Microsoft.FSharp.Collections.ArrayModule.Exists2 predicate array1 array2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exists2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,System.Boolean&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Tests if any pair of corresponding elements of the arrays satisfies the given predicate.</summary>
        <returns>True if any result from <c>predicate</c> is true.</returns>
        <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns true then the overall result is 
 true and no further elements are tested. Otherwise, if one collections is longer 
 than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, false is returned.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] target, int targetIndex, int count, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Fill&lt;T&gt;(!!T[] target, int32 targetIndex, int32 count, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Fill``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (target As T(), targetIndex As Integer, count As Integer, value As T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.fill : 'T[] -&gt; int -&gt; int -&gt; 'T -&gt; unit" Usage="Microsoft.FSharp.Collections.ArrayModule.Fill target targetIndex count value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("fill")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T[]" />
        <Parameter Name="targetIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="target">The target array.</param>
        <param name="targetIndex">The index of the first element to set.</param>
        <param name="count">The number of elements to set.</param>
        <param name="value">The value to set.</param>
        <summary>Fills a range of elements of the array with the given value.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when either targetIndex or count is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="Filter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Filter&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Filter&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Filter(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.filter : ('T -&gt; bool) -&gt; 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Filter predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns a new collection containing only the elements of the collection
 for which the given predicate returns "true".</summary>
        <returns>An array containing the elements for which the given predicate returns true.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Find&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Find``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.find : ('T -&gt; bool) -&gt; 'T[] -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.Find predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("find")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the first element for which the given function returns 'true'.
 Raise <c>KeyNotFoundException</c> if no such element exists.</summary>
        <returns>The first element for which <c>predicate</c> returns true.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T FindBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.FindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindBack(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.findBack : ('T -&gt; bool) -&gt; 'T[] -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.FindBack predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("findBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the last element for which the given function returns 'true'.
 Raise <c>KeyNotFoundException</c> if no such element exists.</summary>
        <returns>The last element for which <c>predicate</c> returns true.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FindIndex&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.FindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As Integer" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.findIndex : ('T -&gt; bool) -&gt; 'T[] -&gt; int" Usage="Microsoft.FSharp.Collections.ArrayModule.FindIndex predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("findIndex")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the index of the first element in the array
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if 
 none of the elements satisfy the predicate.</summary>
        <returns>The index of the first element in the array that satisfies the given predicate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndexBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndexBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FindIndexBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.FindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndexBack(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As Integer" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.findIndexBack : ('T -&gt; bool) -&gt; 'T[] -&gt; int" Usage="Microsoft.FSharp.Collections.ArrayModule.FindIndexBack predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("findIndexBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the index of the last element in the array
 that satisfies the given predicate. Raise <c>KeyNotFoundException</c> if
 none of the elements satisfy the predicate.</summary>
        <returns>The index of the last element in the array that satisfies the given predicate.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if <c>predicate</c>
 never returns true.</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fold&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState Fold&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt; folder, TState state, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState Fold&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TState&gt;&gt; folder, !!TState state, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Fold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Fold(Of T, TState) (folder As FSharpFunc(Of TState, FSharpFunc(Of T, TState)), state As TState, array As T()) As TState" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.fold : ('State -&gt; 'T -&gt; 'State) -&gt; 'State -&gt; 'T[] -&gt; 'State" Usage="Microsoft.FSharp.Collections.ArrayModule.Fold folder state array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("fold")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="state">The initial state.</param>
        <param name="array">The input array.</param>
        <summary>Applies a function to each element of the collection, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f (... (f s i0)...) iN</c></summary>
        <returns>The final state.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fold2&lt;T1,T2,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState Fold2&lt;T1,T2,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TState&gt;&gt;&gt; folder, TState state, T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState Fold2&lt;T1, T2, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TState&gt;&gt;&gt; folder, !!TState state, !!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Fold2``3(Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``2,``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Fold2(Of T1, T2, TState) (folder As FSharpFunc(Of TState, FSharpFunc(Of T1, FSharpFunc(Of T2, TState))), state As TState, array1 As T1(), array2 As T2()) As TState" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.fold2 : ('State -&gt; 'T1 -&gt; 'T2 -&gt; 'State) -&gt; 'State -&gt; 'T1[] -&gt; 'T2[] -&gt; 'State" Usage="Microsoft.FSharp.Collections.ArrayModule.Fold2 folder state array1 array2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("fold2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TState&gt;&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="state">The initial state.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Applies a function to pairs of elements drawn from the two collections, 
 left-to-right, threading an accumulator argument
 through the computation. The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <returns>The final state.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="FoldBack&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState FoldBack&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt; folder, T[] array, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState FoldBack&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, !!TState&gt;&gt; folder, !!T[] array, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.FoldBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``0[],``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FoldBack(Of T, TState) (folder As FSharpFunc(Of T, FSharpFunc(Of TState, TState)), array As T(), state As TState) As TState" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.foldBack : ('T -&gt; 'State -&gt; 'State) -&gt; 'T[] -&gt; 'State -&gt; 'State" Usage="Microsoft.FSharp.Collections.ArrayModule.FoldBack folder array state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("foldBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="array">The input array.</param>
        <param name="state">The initial state.</param>
        <summary>Applies a function to each element of the array, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> then computes 
 <c>f i0 (...(f iN s))</c></summary>
        <returns>The state object after the folding function is applied to each element of the array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="FoldBack2&lt;T1,T2,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState FoldBack2&lt;T1,T2,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;&gt; folder, T1[] array1, T2[] array2, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState FoldBack2&lt;T1, T2, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, !!TState&gt;&gt;&gt; folder, !!T1[] array1, !!T2[] array2, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.FoldBack2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``2}}},``0[],``1[],``2)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FoldBack2(Of T1, T2, TState) (folder As FSharpFunc(Of T1, FSharpFunc(Of T2, FSharpFunc(Of TState, TState))), array1 As T1(), array2 As T2(), state As TState) As TState" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.foldBack2 : ('T1 -&gt; 'T2 -&gt; 'State -&gt; 'State) -&gt; 'T1[] -&gt; 'T2[] -&gt; 'State -&gt; 'State" Usage="Microsoft.FSharp.Collections.ArrayModule.FoldBack2 folder array1 array2 state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("foldBack2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <param name="state">The initial state.</param>
        <summary>Apply a function to pairs of elements drawn from the two collections, right-to-left, 
 threading an accumulator argument through the computation. The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <returns>The final state.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool ForAll&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ForAll``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As Boolean" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.forall : ('T -&gt; bool) -&gt; 'T[] -&gt; bool" Usage="Microsoft.FSharp.Collections.ArrayModule.ForAll predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("forall")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Tests if all elements of the array satisfy the given predicate.</summary>
        <returns>True if all of the array elements satisfy the predicate.</returns>
        <remarks>The predicate is applied to the elements of the input collection. If any application 
 returns false then the overall result is false and no further elements are tested. 
 Otherwise, true is returned.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForAll2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static bool ForAll2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,bool&gt;&gt; predicate, T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool ForAll2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, bool&gt;&gt; predicate, !!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ForAll2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean}},``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForAll2(Of T1, T2) (predicate As FSharpFunc(Of T1, FSharpFunc(Of T2, Boolean)), array1 As T1(), array2 As T2()) As Boolean" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.forall2 : ('T1 -&gt; 'T2 -&gt; bool) -&gt; 'T1[] -&gt; 'T2[] -&gt; bool" Usage="Microsoft.FSharp.Collections.ArrayModule.ForAll2 predicate array1 array2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("forall2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,System.Boolean&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Tests if all corresponding elements of the array satisfy the given predicate pairwise.</summary>
        <returns>True if all of the array elements satisfy the predicate.</returns>
        <remarks>The predicate is applied to matching elements in the two collections up to the lesser of the 
 two lengths of the collections. If any application returns false then the overall result is 
 false and no further elements are tested. Otherwise, if one collection is longer 
 than the other then the <c>ArgumentException</c> exception is raised. 
 Otherwise, true is returned.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="Get&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Get&lt;T&gt; (T[] array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Get&lt;T&gt;(!!T[] array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Get``1(``0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Get(Of T) (array As T(), index As Integer) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.get : 'T[] -&gt; int -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.Get array index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("get")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <param name="index">The input index.</param>
        <summary>Gets an element from an array.</summary>
        <returns>The value of the array at the given index.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.NullReferenceException">Thrown when the input array is null.</exception>
        <exception cref="System.IndexOutOfRangeException">Thrown when the index is negative or the input array does not contain enough elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSubArray&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] GetSubArray&lt;T&gt; (T[] array, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] GetSubArray&lt;T&gt;(!!T[] array, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.GetSubArray``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSubArray(Of T) (array As T(), startIndex As Integer, count As Integer) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.sub : 'T[] -&gt; int -&gt; int -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.GetSubArray array startIndex count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sub")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <param name="startIndex">The index of the first element of the sub array.</param>
        <param name="count">The length of the sub array.</param>
        <summary>Builds a new array that contains the given subrange specified by
 starting index and length.</summary>
        <returns>The created sub array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when either startIndex or count is negative,
 or when there aren't enough elements in the input array.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;TKey,T[]&gt;[] GroupBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!TKey, !!T[]&gt;[] GroupBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.GroupBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GroupBy(Of T, TKey) (projection As FSharpFunc(Of T, TKey), array As T()) As Tuple(Of TKey, T())()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.groupBy : ('T -&gt; 'Key) -&gt; 'T[] -&gt; 'Key * 'T[][]" Usage="Microsoft.FSharp.Collections.ArrayModule.GroupBy projection array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("groupBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;TKey,T[]&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">A function that transforms an element of the array into a comparable key.</param>
        <param name="array">The input array.</param>
        <summary>Applies a key-generating function to each element of an array and yields an array of 
 unique keys. Each unique key contains an array of all elements that match 
 to this key.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Head&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Head&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Head&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Head``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Head(Of T) (array As T()) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.head : 'T[] -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.Head array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("head")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the first element of the array.</summary>
        <returns>The first element of the array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Indexed&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;int,T&gt;[] Indexed&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;int32, !!T&gt;[] Indexed&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Indexed``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Indexed(Of T) (array As T()) As Tuple(Of Integer, T)()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.indexed : 'T[] -&gt; int * 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Indexed array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("indexed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;System.Int32,T&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Builds a new array whose elements are the corresponding elements of the input array
 paired with the integer index (from 0) of each element.</summary>
        <returns>The array of indexed elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Initialize&lt;T&gt; (int count, Microsoft.FSharp.Core.FSharpFunc&lt;int,T&gt; initializer);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Initialize&lt;T&gt;(int32 count, class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, !!T&gt; initializer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Initialize``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{System.Int32,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Initialize(Of T) (count As Integer, initializer As FSharpFunc(Of Integer, T)) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.init : int -&gt; (int -&gt; 'T) -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Initialize count initializer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("init")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="initializer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The number of elements to initialize.</param>
        <param name="initializer">The function to generate the initial values for each index.</param>
        <summary>Creates an array given the dimension and a generator function to compute the elements.</summary>
        <returns>The created array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when count is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsEmpty&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool IsEmpty&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.IsEmpty``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEmpty(Of T) (array As T()) As Boolean" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.isEmpty : 'T[] -&gt; bool" Usage="Microsoft.FSharp.Collections.ArrayModule.IsEmpty array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("isEmpty")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns true if the given array is empty, otherwise false.</summary>
        <returns>True if the array is empty.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Item&lt;T&gt; (int index, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Item&lt;T&gt;(int32 index, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Item``1(System.Int32,``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Item(Of T) (index As Integer, array As T()) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.item : int -&gt; 'T[] -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.Item index array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("item")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="index">The input index.</param>
        <param name="array">The input array.</param>
        <summary>Gets an element from an array.</summary>
        <returns>The value of the array at the given index.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.NullReferenceException">Thrown when the input array is null.</exception>
        <exception cref="System.IndexOutOfRangeException">Thrown when the index is negative or the input array does not contain enough elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Iterate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Iterate&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt; action, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Iterate&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.Unit&gt; action, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Iterate``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Iterate(Of T) (action As FSharpFunc(Of T, Unit), array As T())" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.iter : ('T -&gt; unit) -&gt; 'T[] -&gt; unit" Usage="Microsoft.FSharp.Collections.ArrayModule.Iterate action array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="action">The function to apply.</param>
        <param name="array">The input array.</param>
        <summary>Applies the given function to each element of the array.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Iterate2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static void Iterate2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt; action, T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Iterate2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.Unit&gt;&gt; action, !!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Iterate2``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}},``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Iterate2(Of T1, T2) (action As FSharpFunc(Of T1, FSharpFunc(Of T2, Unit)), array1 As T1(), array2 As T2())" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.iter2 : ('T1 -&gt; 'T2 -&gt; unit) -&gt; 'T1[] -&gt; 'T2[] -&gt; unit" Usage="Microsoft.FSharp.Collections.ArrayModule.Iterate2 action array1 array2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iter2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="action">The function to apply.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Applies the given function to pair of elements drawn from matching indices in two arrays. The
 two arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="IterateIndexed&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IterateIndexed&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;&gt; action, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static void IterateIndexed&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.Unit&gt;&gt; action, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.IterateIndexed``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit}},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IterateIndexed(Of T) (action As FSharpFunc(Of Integer, FSharpFunc(Of T, Unit)), array As T())" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.iteri : (int -&gt; 'T -&gt; unit) -&gt; 'T[] -&gt; unit" Usage="Microsoft.FSharp.Collections.ArrayModule.IterateIndexed action array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iteri")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="action">The function to apply to each index and element.</param>
        <param name="array">The input array.</param>
        <summary>Applies the given function to each element of the array. The integer passed to the
 function indicates the index of element.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="IterateIndexed2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static void IterateIndexed2&lt;T1,T2&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt;&gt; action, T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static void IterateIndexed2&lt;T1, T2&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.Unit&gt;&gt;&gt; action, !!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.IterateIndexed2``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.Unit}}},``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IterateIndexed2(Of T1, T2) (action As FSharpFunc(Of Integer, FSharpFunc(Of T1, FSharpFunc(Of T2, Unit))), array1 As T1(), array2 As T2())" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.iteri2 : (int -&gt; 'T1 -&gt; 'T2 -&gt; unit) -&gt; 'T1[] -&gt; 'T2[] -&gt; unit" Usage="Microsoft.FSharp.Collections.ArrayModule.IterateIndexed2 action array1 array2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("iteri2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.Unit&gt;&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="action">The function to apply to each index and pair of elements.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Applies the given function to pair of elements drawn from matching indices in two arrays,
 also passing the index of the elements. The two arrays must have the same lengths, 
 otherwise an <c>ArgumentException</c> is raised.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Last&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Last&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Last``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Last(Of T) (array As T()) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.last : 'T[] -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.Last array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("last")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the last element of the array.</summary>
        <returns>The last element of the array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input does not have any elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int Length&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Length&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Length``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Length(Of T) (array As T()) As Integer" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.length : 'T[] -&gt; int" Usage="Microsoft.FSharp.Collections.ArrayModule.Length array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("length")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the length of an array. You can also use property arr.Length.</summary>
        <returns>The length of the array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.NullReferenceException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Map&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult[] Map&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; mapping, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult[] Map&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; mapping, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Map(Of T, TResult) (mapping As FSharpFunc(Of T, TResult), array As T()) As TResult()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.map : ('T -&gt; 'Result) -&gt; 'T[] -&gt; 'Result[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Map mapping array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("map")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform elements of the array.</param>
        <param name="array">The input array.</param>
        <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array.</summary>
        <returns>The array of transformed elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Map2&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult[] Map2&lt;T1,T2,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt; mapping, T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult[] Map2&lt;T1, T2, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TResult&gt;&gt; mapping, !!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Map2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Map2(Of T1, T2, TResult) (mapping As FSharpFunc(Of T1, FSharpFunc(Of T2, TResult)), array1 As T1(), array2 As T2()) As TResult()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.map2 : ('T1 -&gt; 'T2 -&gt; 'Result) -&gt; 'T1[] -&gt; 'T2[] -&gt; 'Result[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Map2 mapping array1 array2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("map2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform the pairs of the input elements.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise. The two input
 arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <returns>The array of transformed elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Map3&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult[] Map3&lt;T1,T2,T3,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt; mapping, T1[] array1, T2[] array2, T3[] array3);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult[] Map3&lt;T1, T2, T3, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T3, !!TResult&gt;&gt;&gt; mapping, !!T1[] array1, !!T2[] array2, !!T3[] array3) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Map3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``0[],``1[],``2[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Map3(Of T1, T2, T3, TResult) (mapping As FSharpFunc(Of T1, FSharpFunc(Of T2, FSharpFunc(Of T3, TResult))), array1 As T1(), array2 As T2(), array3 As T3()) As TResult()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.map3 : ('T1 -&gt; 'T2 -&gt; 'T3 -&gt; 'Result) -&gt; 'T1[] -&gt; 'T2[] -&gt; 'T3[] -&gt; 'Result[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Map3 mapping array1 array2 array3" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("map3")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
        <Parameter Name="array3" Type="T3[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform the pairs of the input elements.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <param name="array3">The third input array.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding triples from the three collections. The three input
 arrays must have the same length, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <returns>The array of transformed elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
        <exception cref="System.ArgumentNullException">Thrown when any of the input arrays is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapFold&lt;T,TState,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;TResult[],TState&gt; MapFold&lt;T,TState,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,Tuple&lt;TResult,TState&gt;&gt;&gt; mapping, TState state, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!TResult[], !!TState&gt; MapFold&lt;T, TState, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class System.Tuple`2&lt;!!TResult, !!TState&gt;&gt;&gt; mapping, !!TState state, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.MapFold``3(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{``2,``1}}},``1,``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MapFold(Of T, TState, TResult) (mapping As FSharpFunc(Of TState, FSharpFunc(Of T, Tuple(Of TResult, TState))), state As TState, array As T()) As Tuple(Of TResult(), TState)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.mapFold : ('State -&gt; 'T -&gt; 'Result * 'State) -&gt; 'State -&gt; 'T[] -&gt; 'Result[] * 'State" Usage="Microsoft.FSharp.Collections.ArrayModule.MapFold mapping state array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapFold")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;TResult[],TState&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Tuple&lt;TResult,TState&gt;&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform elements from the input array and accumulate the final value.</param>
        <param name="state">The initial state.</param>
        <param name="array">The input array.</param>
        <summary>Combines map and fold. Builds a new array whose elements are the results of applying the given function
 to each of the elements of the input array. The function is also used to accumulate a final value.</summary>
        <returns>The array of transformed elements, and the final accumulated value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapFoldBack&lt;T,TState,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;TResult[],TState&gt; MapFoldBack&lt;T,TState,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,Tuple&lt;TResult,TState&gt;&gt;&gt; mapping, T[] array, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!TResult[], !!TState&gt; MapFoldBack&lt;T, TState, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class System.Tuple`2&lt;!!TResult, !!TState&gt;&gt;&gt; mapping, !!T[] array, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.MapFoldBack``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}},``0[],``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MapFoldBack(Of T, TState, TResult) (mapping As FSharpFunc(Of T, FSharpFunc(Of TState, Tuple(Of TResult, TState))), array As T(), state As TState) As Tuple(Of TResult(), TState)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.mapFoldBack : ('T -&gt; 'State -&gt; 'Result * 'State) -&gt; 'T[] -&gt; 'State -&gt; 'Result[] * 'State" Usage="Microsoft.FSharp.Collections.ArrayModule.MapFoldBack mapping array state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapFoldBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;TResult[],TState&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,System.Tuple&lt;TResult,TState&gt;&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform elements from the input array and accumulate the final value.</param>
        <param name="array">The input array.</param>
        <param name="state">The initial state.</param>
        <summary>Combines map and foldBack. Builds a new array whose elements are the results of applying the given function
 to each of the elements of the input array. The function is also used to accumulate a final value.</summary>
        <returns>The array of transformed elements, and the final accumulated value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapIndexed&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult[] MapIndexed&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;&gt; mapping, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult[] MapIndexed&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt;&gt; mapping, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.MapIndexed``2(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MapIndexed(Of T, TResult) (mapping As FSharpFunc(Of Integer, FSharpFunc(Of T, TResult)), array As T()) As TResult()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.mapi : (int -&gt; 'T -&gt; 'Result) -&gt; 'T[] -&gt; 'Result[]" Usage="Microsoft.FSharp.Collections.ArrayModule.MapIndexed mapping array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapi")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform elements and their indices.</param>
        <param name="array">The input array.</param>
        <summary>Builds a new array whose elements are the results of applying the given function
 to each of the elements of the array. The integer index passed to the
 function indicates the index of element being transformed.</summary>
        <returns>The array of transformed elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="MapIndexed2&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult[] MapIndexed2&lt;T1,T2,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;&gt; mapping, T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult[] MapIndexed2&lt;T1, T2, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TResult&gt;&gt;&gt; mapping, !!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.MapIndexed2``3(Microsoft.FSharp.Core.FSharpFunc{System.Int32,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MapIndexed2(Of T1, T2, TResult) (mapping As FSharpFunc(Of Integer, FSharpFunc(Of T1, FSharpFunc(Of T2, TResult))), array1 As T1(), array2 As T2()) As TResult()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.mapi2 : (int -&gt; 'T1 -&gt; 'T2 -&gt; 'Result) -&gt; 'T1[] -&gt; 'T2[] -&gt; 'Result[]" Usage="Microsoft.FSharp.Collections.ArrayModule.MapIndexed2 mapping array1 array2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("mapi2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;&gt;" />
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="mapping">The function to transform pairs of input elements and their indices.</param>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Builds a new collection whose elements are the results of applying the given function
 to the corresponding elements of the two collections pairwise, also passing the index of 
 the elements. The two input arrays must have the same lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <returns>The array of transformed elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Max&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Max&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Max``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max(Of T) (array As T()) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.max : 'T[] -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.Max array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("max")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the greatest of all elements of the array, compared via Operators.max on the function result.</summary>
        <returns>The maximum element.</returns>
        <remarks>Throws ArgumentException for empty arrays.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static T MaxBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T MaxBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.MaxBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxBy(Of T, TResult) (projection As FSharpFunc(Of T, TResult), array As T()) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.maxBy : ('T -&gt; 'Result) -&gt; 'T[] -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.MaxBy projection array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("maxBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">The function to transform the elements into a type supporting comparison.</param>
        <param name="array">The input array.</param>
        <summary>Returns the greatest of all elements of the array, compared via Operators.max on the function result.</summary>
        <returns>The maximum element.</returns>
        <remarks>Throws ArgumentException for empty arrays.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Min&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Min&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Min``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min(Of T) (array As T()) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.min : 'T[] -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.Min array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("min")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the lowest of all elements of the array, compared via Operators.min.</summary>
        <returns>The minimum element.</returns>
        <remarks>Throws ArgumentException for empty arrays</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static T MinBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T MinBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.MinBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinBy(Of T, TResult) (projection As FSharpFunc(Of T, TResult), array As T()) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.minBy : ('T -&gt; 'Result) -&gt; 'T[] -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.MinBy projection array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("minBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">The function to transform the elements into a type supporting comparison.</param>
        <param name="array">The input array.</param>
        <summary>Returns the lowest of all elements of the array, compared via Operators.min on the function result.</summary>
        <returns>The minimum element.</returns>
        <remarks>Throws ArgumentException for empty arrays.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfList&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] OfList&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] OfList&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.OfList``1(Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OfList(Of T) (list As FSharpList(Of T)) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.ofList : List&lt;'T&gt; -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.OfList list" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("ofList")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list">The input list.</param>
        <summary>Builds an array from the given list.</summary>
        <returns>The array of elements from the list.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OfSeq&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] OfSeq&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] OfSeq&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.OfSeq``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OfSeq(Of T) (source As IEnumerable(Of T)) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.ofSeq : seq&lt;'T&gt; -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.OfSeq source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("ofSeq")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">The input sequence.</param>
        <summary>Builds a new array from the given enumerable object.</summary>
        <returns>The array of elements from the sequence.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pairwise&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T,T&gt;[] Pairwise&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!T, !!T&gt;[] Pairwise&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Pairwise``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pairwise(Of T) (array As T()) As Tuple(Of T, T)()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.pairwise : 'T[] -&gt; 'T * 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Pairwise array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("pairwise")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T,T&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns an array of each element in the input array and its predecessor, with the
 exception of the first element which is only returned as the predecessor of the second element.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Partition&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T[],T[]&gt; Partition&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!T[], !!T[]&gt; Partition&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Partition``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Partition(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As Tuple(Of T(), T())" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.partition : ('T -&gt; bool) -&gt; 'T[] -&gt; 'T[] * 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Partition predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("partition")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T[],T[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Splits the collection into two collections, containing the 
 elements for which the given predicate returns "true" and "false"
 respectively.</summary>
        <returns>A pair of arrays. The first containing the elements the predicate evaluated to true,
 and the second containing those evaluated to false.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Permute&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Permute&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;int,int&gt; indexMap, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Permute&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;int32, int32&gt; indexMap, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Permute``1(Microsoft.FSharp.Core.FSharpFunc{System.Int32,System.Int32},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Permute(Of T) (indexMap As FSharpFunc(Of Integer, Integer), array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.permute : (int -&gt; int) -&gt; 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Permute indexMap array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("permute")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="indexMap" Type="Microsoft.FSharp.Core.FSharpFunc&lt;System.Int32,System.Int32&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="indexMap">The function that maps input indices to output indices.</param>
        <param name="array">The input array.</param>
        <summary>Returns an array with all elements permuted according to the
 specified permutation.</summary>
        <returns>The output array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when indexMap does not produce a valid permutation.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pick&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Pick&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt; chooser, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult Pick&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt;&gt; chooser, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Pick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pick(Of T, TResult) (chooser As FSharpFunc(Of T, FSharpOption(Of TResult)), array As T()) As TResult" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.pick : ('T -&gt; option&lt;'Result&gt;) -&gt; 'T[] -&gt; 'Result" Usage="Microsoft.FSharp.Collections.ArrayModule.Pick chooser array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("pick")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chooser" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="chooser">The function to generate options from the elements.</param>
        <param name="array">The input array.</param>
        <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>KeyNotFoundException</c> is raised.</summary>
        <returns>The first result.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.Collections.Generic.KeyNotFoundException">Thrown if every result from
 <c>chooser</c> is <c>None</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reduce&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Reduce&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt; reduction, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Reduce&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!T&gt;&gt; reduction, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Reduce``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reduce(Of T) (reduction As FSharpFunc(Of T, FSharpFunc(Of T, T)), array As T()) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.reduce : ('T -&gt; 'T -&gt; 'T) -&gt; 'T[] -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.Reduce reduction array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("reduce")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reduction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="reduction">The function to reduce a pair of elements to a single element.</param>
        <param name="array">The input array.</param>
        <summary>Applies a function to each element of the array, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f (... (f i0 i1)...) iN</c>.
 Raises ArgumentException if the array has size zero.</summary>
        <returns>The final result of the reductions.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReduceBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ReduceBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt; reduction, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T ReduceBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!T&gt;&gt; reduction, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ReduceBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReduceBack(Of T) (reduction As FSharpFunc(Of T, FSharpFunc(Of T, T)), array As T()) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.reduceBack : ('T -&gt; 'T -&gt; 'T) -&gt; 'T[] -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.ReduceBack reduction array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("reduceBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reduction" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,T&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="reduction">A function that takes in the next-to-last element of the list and the
 current accumulated result to produce the next accumulated result.</param>
        <param name="array">The input array.</param>
        <summary>Applies a function to each element of the array, starting from the end, threading an accumulator argument
 through the computation. If the input function is <c>f</c> and the elements are <c>i0...iN</c> 
 then computes <c>f i0 (...(f iN-1 iN))</c>.</summary>
        <returns>The final result of the reductions.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replicate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Replicate&lt;T&gt; (int count, T initial);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Replicate&lt;T&gt;(int32 count, !!T initial) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Replicate``1(System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Replicate(Of T) (count As Integer, initial As T) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.replicate : int -&gt; 'T -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Replicate count initial" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("replicate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="initial" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The number of elements to replicate.</param>
        <param name="initial">The value to replicate</param>
        <summary>Creates an array by replicating the given initial value.</summary>
        <returns>The generated array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when count is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reverse(Of T) (array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.rev : 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("rev")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns a new array with the elements in reverse order.</summary>
        <returns>The reversed array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scan&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState[] Scan&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt; folder, TState state, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState[] Scan&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TState&gt;&gt; folder, !!TState state, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Scan``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``1,``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Scan(Of T, TState) (folder As FSharpFunc(Of TState, FSharpFunc(Of T, TState)), state As TState, array As T()) As TState()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.scan : ('State -&gt; 'T -&gt; 'State) -&gt; 'State -&gt; 'T[] -&gt; 'State[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Scan folder state array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("scan")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpFunc&lt;T,TState&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="state">The initial state.</param>
        <param name="array">The input array.</param>
        <summary>Like <c>fold</c>, but return the intermediary and final results.</summary>
        <returns>The array of state values.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScanBack&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static TState[] ScanBack&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt; folder, T[] array, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TState[] ScanBack&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, !!TState&gt;&gt; folder, !!T[] array, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ScanBack``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``1}},``0[],``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ScanBack(Of T, TState) (folder As FSharpFunc(Of T, FSharpFunc(Of TState, TState)), array As T(), state As TState) As TState()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.scanBack : ('T -&gt; 'State -&gt; 'State) -&gt; 'T[] -&gt; 'State -&gt; 'State[]" Usage="Microsoft.FSharp.Collections.ArrayModule.ScanBack folder array state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("scanBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TState[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="folder" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;TState,TState&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="folder">The function to update the state given the input elements.</param>
        <param name="array">The input array.</param>
        <param name="state">The initial state.</param>
        <summary>Like <c>foldBack</c>, but return both the intermediary and final results.</summary>
        <returns>The array of state values.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Set&lt;T&gt; (T[] array, int index, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Set&lt;T&gt;(!!T[] array, int32 index, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Set``1(``0[],System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Set(Of T) (array As T(), index As Integer, value As T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.set : 'T[] -&gt; int -&gt; 'T -&gt; unit" Usage="Microsoft.FSharp.Collections.ArrayModule.Set array index value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("set")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <param name="index">The input index.</param>
        <param name="value">The input value.</param>
        <summary>Sets an element of an array.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.NullReferenceException">Thrown when the input array is null.</exception>
        <exception cref="System.IndexOutOfRangeException">Thrown when the index is negative or the input array does not contain enough elements.</exception>
      </Docs>
    </Member>
    <Member MemberName="Singleton&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Singleton&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Singleton&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Singleton``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Singleton(Of T) (value As T) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.singleton : 'T -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Singleton value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("singleton")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input item.</param>
        <summary>Returns an array that contains one item only.</summary>
        <returns>The result array of one item.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Skip&lt;T&gt; (int count, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Skip&lt;T&gt;(int32 count, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Skip``1(System.Int32,``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Skip(Of T) (count As Integer, array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.skip : int -&gt; 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Skip count array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("skip")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The number of elements to skip.</param>
        <param name="array">The input array.</param>
        <summary>Builds a new array that contains the elements of the given array, excluding the first N elements.</summary>
        <returns>A copy of the input array, after removing the first N elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentExcepion">Thrown when count is negative or exceeds the number of 
 elements in the array.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] SkipWhile&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] SkipWhile&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SkipWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SkipWhile(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.skipWhile : ('T -&gt; bool) -&gt; 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.SkipWhile predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("skipWhile")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function that evaluates an element of the array to a boolean value.</param>
        <param name="array">To be added.</param>
        <summary>Bypasses elements in an array while the given predicate returns True, and then returns
 the remaining elements in a new array.</summary>
        <returns>The created sub array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sort(Of T) (array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.sort : 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sort")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array, returning a new array. Elements are compared using Operators.compare. </summary>
        <returns>The sorted array.</returns>
        <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static T[] SortBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] SortBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SortBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SortBy(Of T, TKey) (projection As FSharpFunc(Of T, TKey), array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.sortBy : ('T -&gt; 'Key) -&gt; 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.SortBy projection array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">The function to transform array elements into the type that is compared.</param>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array, using the given projection for the keys and returning a new array. 
 Elements are compared using Operators.compare.</summary>
        <returns>The sorted array.</returns>
        <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortByDescending&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static T[] SortByDescending&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] SortByDescending&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SortByDescending``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SortByDescending(Of T, TKey) (projection As FSharpFunc(Of T, TKey), array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.sortByDescending : ('T -&gt; 'Key) -&gt; 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.SortByDescending projection array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortByDescending")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">The function to transform array elements into the type that is compared.</param>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array, in descending order, using the given projection for the keys and returning a new array. 
 Elements are compared using Operators.compare.</summary>
        <returns>The sorted array.</returns>
        <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SortDescending&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] SortDescending&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] SortDescending&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SortDescending``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SortDescending(Of T) (array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.sortDescending : 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.SortDescending array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortDescending")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array, in descending order, returning a new array. Elements are compared using Operators.compare. </summary>
        <returns>The sorted array.</returns>
        <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SortInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void SortInPlace&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SortInPlace&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlace``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SortInPlace(Of T) (array As T())" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.sortInPlace : 'T[] -&gt; unit" Usage="Microsoft.FSharp.Collections.ArrayModule.SortInPlace array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortInPlace")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array by mutating the array in-place, using the given comparison function. 
 Elements are compared using Operators.compare.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortInPlaceBy&lt;T,TKey&gt;">
      <MemberSignature Language="C#" Value="public static void SortInPlaceBy&lt;T,TKey&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SortInPlaceBy&lt;T, TKey&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TKey&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlaceBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SortInPlaceBy(Of T, TKey) (projection As FSharpFunc(Of T, TKey), array As T())" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.sortInPlaceBy : ('T -&gt; 'Key) -&gt; 'T[] -&gt; unit" Usage="Microsoft.FSharp.Collections.ArrayModule.SortInPlaceBy projection array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortInPlaceBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TKey&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TKey">To be added.</typeparam>
        <param name="projection">The function to transform array elements into the type that is compared.</param>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array by mutating the array in-place, using the given projection for the keys. 
 Elements are compared using Operators.compare.</summary>
        <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortInPlaceWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void SortInPlaceWith&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,int&gt;&gt; comparer, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SortInPlaceWith&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, int32&gt;&gt; comparer, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SortInPlaceWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SortInPlaceWith(Of T) (comparer As FSharpFunc(Of T, FSharpFunc(Of T, Integer)), array As T())" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.sortInPlaceWith : ('T -&gt; 'T -&gt; int) -&gt; 'T[] -&gt; unit" Usage="Microsoft.FSharp.Collections.ArrayModule.SortInPlaceWith comparer array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortInPlaceWith")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Int32&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="comparer">The function to compare pairs of array elements.</param>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array by mutating the array in-place, using the given comparison function as the order.</summary>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SortWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] SortWith&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,int&gt;&gt; comparer, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] SortWith&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, int32&gt;&gt; comparer, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SortWith``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Int32}},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SortWith(Of T) (comparer As FSharpFunc(Of T, FSharpFunc(Of T, Integer)), array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.sortWith : ('T -&gt; 'T -&gt; int) -&gt; 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.SortWith comparer array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sortWith")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="comparer" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Int32&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="comparer">The function to compare pairs of array elements.</param>
        <param name="array">The input array.</param>
        <summary>Sorts the elements of an array, using the given comparison function as the order, returning a new array.</summary>
        <returns>The sorted array.</returns>
        <remarks>This is not a stable sort, i.e. the original order of equal elements is not necessarily preserved. 
 For a stable sort, consider using Seq.sort.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SplitAt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T[],T[]&gt; SplitAt&lt;T&gt; (int index, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!T[], !!T[]&gt; SplitAt&lt;T&gt;(int32 index, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SplitAt``1(System.Int32,``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SplitAt(Of T) (index As Integer, array As T()) As Tuple(Of T(), T())" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.splitAt : int -&gt; 'T[] -&gt; 'T[] * 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.SplitAt index array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("splitAt")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T[],T[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="index">The index at which the array is split.</param>
        <param name="array">The input array.</param>
        <summary>Splits an array into two arrays, at the given index.</summary>
        <returns>The two split arrays.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.InvalidOperationException">Thrown when split index exceeds the number of elements
 in the array.</exception>
      </Docs>
    </Member>
    <Member MemberName="SplitInto&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[][] SplitInto&lt;T&gt; (int count, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[][] SplitInto&lt;T&gt;(int32 count, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SplitInto``1(System.Int32,``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SplitInto(Of T) (count As Integer, array As T()) As T()()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.splitInto : int -&gt; 'T[] -&gt; 'T[][]" Usage="Microsoft.FSharp.Collections.ArrayModule.SplitInto count array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("splitInto")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[][]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The maximum number of chunks.</param>
        <param name="array">The input array.</param>
        <summary>Splits the input array into at most <c>count</c> chunks.</summary>
        <returns>The array split into chunks.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when <c>count</c> is not positive.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sum&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Sum&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Sum``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sum(Of T) (array As T()) As T" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.sum : 'T[] -&gt; 'T" Usage="Microsoft.FSharp.Collections.ArrayModule.Sum array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sum")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the sum of the elements in the array.</summary>
        <returns>The resulting sum.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="SumBy&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult SumBy&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; projection, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult SumBy&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; projection, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.SumBy``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SumBy(Of T, TResult) (projection As FSharpFunc(Of T, TResult), array As T()) As TResult" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.sumBy : ('T -&gt; 'Result) -&gt; 'T[] -&gt; 'Result" Usage="Microsoft.FSharp.Collections.ArrayModule.SumBy projection array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sumBy")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="projection" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="projection">The function to transform the array elements into the type to be summed.</param>
        <param name="array">The input array.</param>
        <summary>Returns the sum of the results generated by applying the function to each element of the array.</summary>
        <returns>The resulting sum.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Tail&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Tail&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Tail&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Tail``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tail(Of T) (array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.tail : 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Tail array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tail")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns a new array containing the elements of the original except the first element.</summary>
        <returns>A new array containing the elements of the original except the first element.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when the array is empty.</exception>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Take&lt;T&gt; (int count, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Take&lt;T&gt;(int32 count, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Take``1(System.Int32,``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Take(Of T) (count As Integer, array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.take : int -&gt; 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Take count array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("take")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The number of items to take.</param>
        <param name="array">The input array.</param>
        <summary>Returns the first N elements of the array.</summary>
        <returns>The result array.</returns>
        <remarks>Throws <c>InvalidOperationException</c>
 if the count exceeds the number of elements in the array. <c>Array.truncate</c>
 returns as many items as the array contains instead of throwing an exception.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input array is empty.</exception>
        <exception cref="System.InvalidOperationException">Thrown when count exceeds the number of elements
 in the list.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] TakeWhile&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] TakeWhile&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TakeWhile``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakeWhile(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.takeWhile : ('T -&gt; bool) -&gt; 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.TakeWhile predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("takeWhile")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">A function that evaluates to false when no more items should be returned.</param>
        <param name="array">The input array.</param>
        <summary>Returns an array that contains all elements of the original array while the 
 given predicate returns True, and then returns no further elements.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; ToList&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; ToList&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ToList``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToList(Of T) (array As T()) As FSharpList(Of T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.toList : 'T[] -&gt; List&lt;'T&gt;" Usage="Microsoft.FSharp.Collections.ArrayModule.ToList array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("toList")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Builds a list from the given array.</summary>
        <returns>The list of array elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToSeq&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; ToSeq&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; ToSeq&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ToSeq``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToSeq(Of T) (array As T()) As IEnumerable(Of T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.toSeq : 'T[] -&gt; seq&lt;'T&gt;" Usage="Microsoft.FSharp.Collections.ArrayModule.ToSeq array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("toSeq")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Views the given array as a sequence.</summary>
        <returns>The sequence of array elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Transpose&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[][] Transpose&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T[]&gt; arrays);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[][] Transpose&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T[]&gt; arrays) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Transpose``1(System.Collections.Generic.IEnumerable{``0[]})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Transpose(Of T) (arrays As IEnumerable(Of T())) As T()()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.transpose : seq&lt;'T[]&gt; -&gt; 'T[][]" Usage="Microsoft.FSharp.Collections.ArrayModule.Transpose arrays" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("transpose")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[][]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arrays" Type="System.Collections.Generic.IEnumerable&lt;T[]&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="arrays">The input sequence of arrays.</param>
        <summary>Returns the transpose of the given sequence of arrays.</summary>
        <returns>The transposed array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="Truncate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Truncate&lt;T&gt; (int count, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Truncate&lt;T&gt;(int32 count, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Truncate``1(System.Int32,``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate(Of T) (count As Integer, array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.truncate : int -&gt; 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Truncate count array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("truncate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The maximum number of items to return.</param>
        <param name="array">The input array.</param>
        <summary>Returns at most N elements in a new array.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFind&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryFind&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryFind&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryFind``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFind(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As FSharpOption(Of T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.tryFind : ('T -&gt; bool) -&gt; 'T[] -&gt; option&lt;'T&gt;" Usage="Microsoft.FSharp.Collections.ArrayModule.TryFind predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFind")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the first element for which the given function returns True.
 Return None if no such element exists.</summary>
        <returns>The first element that satisfies the predicate, or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFindBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryFindBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryFindBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryFindBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFindBack(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As FSharpOption(Of T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.tryFindBack : ('T -&gt; bool) -&gt; 'T[] -&gt; option&lt;'T&gt;" Usage="Microsoft.FSharp.Collections.ArrayModule.TryFindBack predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFindBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the last element for which the given function returns True.
 Return None if no such element exists.</summary>
        <returns>The last element that satisfies the predicate, or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;int&gt; TryFindIndex&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; TryFindIndex&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryFindIndex``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFindIndex(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As FSharpOption(Of Integer)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.tryFindIndex : ('T -&gt; bool) -&gt; 'T[] -&gt; option&lt;int&gt;" Usage="Microsoft.FSharp.Collections.ArrayModule.TryFindIndex predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFindIndex")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the index of the first element in the array
 that satisfies the given predicate.</summary>
        <returns>The index of the first element that satisfies the predicate, or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryFindIndexBack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;int&gt; TryFindIndexBack&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;int32&gt; TryFindIndexBack&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryFindIndexBack``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryFindIndexBack(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As FSharpOption(Of Integer)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.tryFindIndexBack : ('T -&gt; bool) -&gt; 'T[] -&gt; option&lt;int&gt;" Usage="Microsoft.FSharp.Collections.ArrayModule.TryFindIndexBack predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryFindIndexBack")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns the index of the last element in the array
 that satisfies the given predicate.</summary>
        <returns>The index of the last element that satisfies the predicate, or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryHead&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryHead&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryHead&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryHead``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryHead(Of T) (array As T()) As FSharpOption(Of T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.tryHead : 'T[] -&gt; option&lt;'T&gt;" Usage="Microsoft.FSharp.Collections.ArrayModule.TryHead array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryHead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the first element of the array, or
 <c>None</c> if the array is empty.</summary>
        <returns>The first element of the array or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryItem&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryItem&lt;T&gt; (int index, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryItem&lt;T&gt;(int32 index, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryItem``1(System.Int32,``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryItem(Of T) (index As Integer, array As T()) As FSharpOption(Of T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.tryItem : int -&gt; 'T[] -&gt; option&lt;'T&gt;" Usage="Microsoft.FSharp.Collections.ArrayModule.TryItem index array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryItem")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="index">The index of element to retrieve.</param>
        <param name="array">To be added.</param>
        <summary>Tries to find the nth element in the array.
 Returns <c>None</c> if index is negative or the input array does not contain enough elements.</summary>
        <returns>The nth element of the array or <c>None</c>.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryLast&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryLast&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryLast``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryLast(Of T) (array As T()) As FSharpOption(Of T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.tryLast : 'T[] -&gt; option&lt;'T&gt;" Usage="Microsoft.FSharp.Collections.ArrayModule.TryLast array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryLast")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Returns the last element of the array.
 Return <c>None</c> if no such element exists.</summary>
        <returns>The last element of the array or None.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input sequence is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryPick&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt; TryPick&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt; chooser, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt; TryPick&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt;&gt; chooser, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.TryPick``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryPick(Of T, TResult) (chooser As FSharpFunc(Of T, FSharpOption(Of TResult)), array As T()) As FSharpOption(Of TResult)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.tryPick : ('T -&gt; option&lt;'Result&gt;) -&gt; 'T[] -&gt; option&lt;'Result&gt;" Usage="Microsoft.FSharp.Collections.ArrayModule.TryPick chooser array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryPick")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="chooser" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="chooser">The function to transform the array elements into options.</param>
        <param name="array">The input array.</param>
        <summary>Applies the given function to successive elements, returning the first
 result where function returns <c>Some(x)</c> for some <c>x</c>. If the function 
 never returns <c>Some(x)</c> then <c>None</c> is returned.</summary>
        <returns>The first transformed element that is <c>Some(x)</c>.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unfold&lt;T,TState&gt;">
      <MemberSignature Language="C#" Value="public static T[] Unfold&lt;T,TState&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpOption&lt;Tuple&lt;T,TState&gt;&gt;&gt; generator, TState state);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Unfold&lt;T, TState&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TState, class Microsoft.FSharp.Core.FSharpOption`1&lt;class System.Tuple`2&lt;!!T, !!TState&gt;&gt;&gt; generator, !!TState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Unfold``2(Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``0,``1}}},``1)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unfold(Of T, TState) (generator As FSharpFunc(Of TState, FSharpOption(Of Tuple(Of T, TState))), state As TState) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.unfold : ('State -&gt; option&lt;'T * 'State&gt;) -&gt; 'State -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Unfold generator state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("unfold")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="generator" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TState,Microsoft.FSharp.Core.FSharpOption&lt;System.Tuple&lt;T,TState&gt;&gt;&gt;" />
        <Parameter Name="state" Type="TState" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TState">To be added.</typeparam>
        <param name="generator">A function that takes in the current state and returns an option tuple of the next
 element of the array and the next state value.</param>
        <param name="state">The initial state value.</param>
        <summary>Returns an array that contains the elements generated by the given computation.
 The given initial <c>state</c> argument is passed to the element generator.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unzip&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T1[],T2[]&gt; Unzip&lt;T1,T2&gt; (Tuple&lt;T1,T2&gt;[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!T1[], !!T2[]&gt; Unzip&lt;T1, T2&gt;(class System.Tuple`2&lt;!!T1, !!T2&gt;[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Unzip``2(System.Tuple{``0,``1}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unzip(Of T1, T2) (array As Tuple(Of T1, T2)()) As Tuple(Of T1(), T2())" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.unzip : ('T1 * 'T2[]) -&gt; 'T1[] * 'T2[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Unzip array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("unzip")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T1[],T2[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="System.Tuple&lt;T1,T2&gt;[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Splits an array of pairs into two arrays.</summary>
        <returns>The two arrays.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unzip3&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T1[],T2[],T3[]&gt; Unzip3&lt;T1,T2,T3&gt; (Tuple&lt;T1,T2,T3&gt;[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`3&lt;!!T1[], !!T2[], !!T3[]&gt; Unzip3&lt;T1, T2, T3&gt;(class System.Tuple`3&lt;!!T1, !!T2, !!T3&gt;[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Unzip3``3(System.Tuple{``0,``1,``2}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unzip3(Of T1, T2, T3) (array As Tuple(Of T1, T2, T3)()) As Tuple(Of T1(), T2(), T3())" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.unzip3 : ('T1 * 'T2 * 'T3[]) -&gt; 'T1[] * 'T2[] * 'T3[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Unzip3 array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("unzip3")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T1[],T2[],T3[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="System.Tuple&lt;T1,T2,T3&gt;[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="array">The input array.</param>
        <summary>Splits an array of triples into three arrays.</summary>
        <returns>The tuple of three arrays.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Where&lt;T&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] Where&lt;T&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Where``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Where(Of T) (predicate As FSharpFunc(Of T, Boolean), array As T()) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.where : ('T -&gt; bool) -&gt; 'T[] -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Where predicate array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("where")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="predicate">The function to test the input elements.</param>
        <param name="array">The input array.</param>
        <summary>Returns a new array containing only the elements of the array
 for which the given predicate returns "true".</summary>
        <returns>An array containing the elements for which the given predicate returns true.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Windowed&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[][] Windowed&lt;T&gt; (int windowSize, T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[][] Windowed&lt;T&gt;(int32 windowSize, !!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Windowed``1(System.Int32,``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Windowed(Of T) (windowSize As Integer, array As T()) As T()()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.windowed : int -&gt; 'T[] -&gt; 'T[][]" Usage="Microsoft.FSharp.Collections.ArrayModule.Windowed windowSize array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("windowed")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[][]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="windowSize" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="windowSize">The number of elements in each window.</param>
        <param name="array">The input array.</param>
        <summary>Returns an array of sliding windows containing elements drawn from the input
 array. Each window is returned as a fresh array.</summary>
        <returns>The result array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when the input array is null.</exception>
        <exception cref="System.ArgumentException">Thrown when windowSize is not positive.</exception>
      </Docs>
    </Member>
    <Member MemberName="ZeroCreate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] ZeroCreate&lt;T&gt; (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T[] ZeroCreate&lt;T&gt;(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.ZeroCreate``1(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ZeroCreate(Of T) (count As Integer) As T()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.zeroCreate : int -&gt; 'T[]" Usage="Microsoft.FSharp.Collections.ArrayModule.ZeroCreate count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("zeroCreate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="count">The length of the array to create.</param>
        <summary>Creates an array where the entries are initially the default value Unchecked.defaultof&lt;'T&gt;.</summary>
        <returns>The created array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentException">Thrown when count is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T1,T2&gt;[] Zip&lt;T1,T2&gt; (T1[] array1, T2[] array2);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!T1, !!T2&gt;[] Zip&lt;T1, T2&gt;(!!T1[] array1, !!T2[] array2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Zip``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Zip(Of T1, T2) (array1 As T1(), array2 As T2()) As Tuple(Of T1, T2)()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.zip : 'T1[] -&gt; 'T2[] -&gt; 'T1 * 'T2[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Zip array1 array2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("zip")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T1,T2&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <summary>Combines the two arrays into an array of pairs. The two arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <returns>The array of tupled elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when either of the input arrays is null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip3&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;T1,T2,T3&gt;[] Zip3&lt;T1,T2,T3&gt; (T1[] array1, T2[] array2, T3[] array3);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`3&lt;!!T1, !!T2, !!T3&gt;[] Zip3&lt;T1, T2, T3&gt;(!!T1[] array1, !!T2[] array2, !!T3[] array3) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Collections.ArrayModule.Zip3``3(``0[],``1[],``2[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Zip3(Of T1, T2, T3) (array1 As T1(), array2 As T2(), array3 As T3()) As Tuple(Of T1, T2, T3)()" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Collections.Array.zip3 : 'T1[] -&gt; 'T2[] -&gt; 'T3[] -&gt; 'T1 * 'T2 * 'T3[]" Usage="Microsoft.FSharp.Collections.ArrayModule.Zip3 array1 array2 array3" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("zip3")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;T1,T2,T3&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array1" Type="T1[]" />
        <Parameter Name="array2" Type="T2[]" />
        <Parameter Name="array3" Type="T3[]" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="array1">The first input array.</param>
        <param name="array2">The second input array.</param>
        <param name="array3">The third input array.</param>
        <summary>Combines three arrays into an array of pairs. The three arrays must have equal lengths, otherwise an <c>ArgumentException</c> is
 raised.</summary>
        <returns>The array of tupled elements.</returns>
        <remarks>To be added.</remarks>
        <exception cref="System.ArgumentNullException">Thrown when any of the input arrays are null.</exception>
        <exception cref="System.ArgumentException">Thrown when the input arrays differ in length.</exception>
      </Docs>
    </Member>
  </Members>
</Type>