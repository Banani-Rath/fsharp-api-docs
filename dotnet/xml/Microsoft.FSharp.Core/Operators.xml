<Type Name="Operators" FullName="Microsoft.FSharp.Core.Operators">
  <TypeSignature Language="C#" Value="public static class Operators" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Operators extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.FSharp.Core.Operators" />
  <AssemblyInfo>
    <AssemblyName>FSharp.Core</AssemblyName>
    <AssemblyVersion>4.4.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.AutoOpen</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationMapping(Microsoft.FSharp.Core.SourceConstructFlags.Module)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Basic F# Operators. This module is automatically opened in all F# code.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Abs&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Abs&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Abs``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("abs")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Absolute value of the given number.</summary>
        <returns>The absolute value of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Acos&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Acos&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Acos``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("acos")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Inverse cosine of the given number</summary>
        <returns>The inverse cosine of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Asin&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Asin&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Asin``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("asin")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Inverse sine of the given number</summary>
        <returns>The inverse sine of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Atan&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Atan&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Atan``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("atan")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Inverse tangent of the given number</summary>
        <returns>The inverse tangent of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static T2 Atan2&lt;T1,T2&gt; (T1 y, T1 x);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T2 Atan2&lt;T1, T2&gt;(!!T1 y, !!T1 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Atan2``2(``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("atan2")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T2</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="T1" />
        <Parameter Name="x" Type="T1" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="y">The y input value.</param>
        <param name="x">The x input value.</param>
        <summary>Inverse tangent of <c>x/y</c> where <c>x</c> and <c>y</c> are specified separately</summary>
        <returns>The inverse tangent of the input ratio.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Box&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static object Box&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Box&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Box``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("box")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The value to box.</param>
        <summary>Boxes a strongly typed value.</summary>
        <returns>The boxed object.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceiling&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Ceiling&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Ceiling&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Ceiling``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("ceil")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Ceiling of the given number</summary>
        <returns>The ceiling of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int Compare&lt;T&gt; (T e1, T e2);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Compare&lt;T&gt;(!!T e1, !!T e2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Compare``1(``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("compare")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="e1" Type="T" />
        <Parameter Name="e2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="e1">The first value.</param>
        <param name="e2">The second value.</param>
        <summary>Generic comparison.</summary>
        <returns>The result of the comparison.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConsoleError&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter ConsoleError&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.TextWriter ConsoleError&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ConsoleError``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("stderr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Reads the value of the property <c>System.Console.Error</c>. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConsoleIn&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.IO.TextReader ConsoleIn&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.TextReader ConsoleIn&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ConsoleIn``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("stdin")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Reads the value of the property <c>System.Console.In</c>. </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConsoleOut&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter ConsoleOut&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.IO.TextWriter ConsoleOut&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ConsoleOut``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("stdout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Reads the value of the property <c>System.Console.Out</c>.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Cos&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Cos&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Cos``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("cos")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Cosine of the given number</summary>
        <returns>The cosine of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Cosh&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Cosh&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Cosh``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("cosh")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Hyperbolic cosine  of the given number</summary>
        <returns>The hyperbolic cosine of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSequence&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; CreateSequence&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; sequence);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; CreateSequence&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; sequence) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.CreateSequence``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("seq")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="sequence" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="sequence">The input sequence.</param>
        <summary>Builds a sequence using sequence expression syntax</summary>
        <returns>The result sequence.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrement">
      <MemberSignature Language="C#" Value="public static void Decrement (Microsoft.FSharp.Core.FSharpRef&lt;int&gt; cell);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Decrement(class Microsoft.FSharp.Core.FSharpRef`1&lt;int32&gt; cell) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Decrement(Microsoft.FSharp.Core.FSharpRef{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("decr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cell" Type="Microsoft.FSharp.Core.FSharpRef&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="cell">The reference cell.</param>
        <summary>Decrement a mutable reference cell containing an integer</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultArg&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T DefaultArg&lt;T&gt; (Microsoft.FSharp.Core.FSharpOption&lt;T&gt; arg, T defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T DefaultArg&lt;T&gt;(class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; arg, !!T defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.DefaultArg``1(Microsoft.FSharp.Core.FSharpOption{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("defaultArg")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arg" Type="Microsoft.FSharp.Core.FSharpOption&lt;T&gt;" />
        <Parameter Name="defaultValue" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="arg">An option representing the argument.</param>
        <param name="defaultValue">The default value of the argument.</param>
        <summary>Used to specify a default value for an optional argument in the implementation of a function</summary>
        <returns>The argument value. If it is None, the defaultValue is returned.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exit&lt;T&gt; (int exitcode);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Exit&lt;T&gt;(int32 exitcode) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Exit``1(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exit")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exitcode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="exitcode">The exit code to use.</param>
        <summary>Exit the current hardware isolated process, if security settings permit,
 otherwise raise an exception. Calls <c>System.Environment.Exit</c>.</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Exp&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Exp&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Exp``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("exp")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Exponential of the given number</summary>
        <returns>The exponential of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Failure">
      <MemberSignature Language="C#" Value="public static Exception Failure (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Exception Failure(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Failure(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">The message for the Exception.</param>
        <summary>Builds a <c>System.Exception</c> object.</summary>
        <returns>A System.Exception.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FailurePattern">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;string&gt; FailurePattern (Exception error);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;string&gt; FailurePattern(class System.Exception error) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.FailurePattern(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("|Failure|_|")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="error" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="error">The input exception.</param>
        <summary>Matches <c>System.Exception</c> objects whose runtime type is precisely <c>System.Exception</c></summary>
        <returns>A string option.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FailWith&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FailWith&lt;T&gt; (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T FailWith&lt;T&gt;(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.FailWith``1(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("failwith")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="message">The exception message.</param>
        <summary>Throw a <c>System.Exception</c> exception.</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Floor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Floor&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Floor&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Floor``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("floor")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Floor of the given number</summary>
        <returns>The floor of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fst&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static T1 Fst&lt;T1,T2&gt; (Tuple&lt;T1,T2&gt; tuple);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T1 Fst&lt;T1, T2&gt;(class System.Tuple`2&lt;!!T1, !!T2&gt; tuple) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Fst``2(System.Tuple{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("fst")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T1</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tuple" Type="System.Tuple&lt;T1,T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="tuple">The input tuple.</param>
        <summary>Return the first element of a tuple, <c>fst (a,b) = a</c>.</summary>
        <returns>The first value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hash&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int Hash&lt;T&gt; (T obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Hash&lt;T&gt;(!!T obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Hash``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("hash")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="obj" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="obj">The input object.</param>
        <summary>A generic hash function, designed to return equal hash values for items that are 
 equal according to the "=" operator. By default it will use structural hashing
 for F# union, record and tuple types, hashing the complete contents of the 
 type. The exact behaviour of the function can be adjusted on a 
 type-by-type basis by implementing GetHashCode for each type.</summary>
        <returns>The computed hash.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Identity&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Identity&lt;T&gt; (T x);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Identity&lt;T&gt;(!!T x) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Identity``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("id")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input value.</param>
        <summary>The identity function</summary>
        <returns>The same value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ignore&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Ignore&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Ignore&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Ignore``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("ignore")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The value to ignore.</param>
        <summary>Ignore the passed value. This is often used to throw away results of a computation.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Increment">
      <MemberSignature Language="C#" Value="public static void Increment (Microsoft.FSharp.Core.FSharpRef&lt;int&gt; cell);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Increment(class Microsoft.FSharp.Core.FSharpRef`1&lt;int32&gt; cell) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Increment(Microsoft.FSharp.Core.FSharpRef{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("incr")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cell" Type="Microsoft.FSharp.Core.FSharpRef&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="cell">The reference cell.</param>
        <summary>Increment a mutable reference cell containing an integer</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Infinity">
      <MemberSignature Language="C#" Value="public static double Infinity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float64 Infinity" />
      <MemberSignature Language="DocId" Value="P:Microsoft.FSharp.Core.Operators.Infinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompiledName("Infinity")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Equivalent to <c>System.Double.PositiveInfinity</c></summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InfinitySingle">
      <MemberSignature Language="C#" Value="public static float InfinitySingle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float32 InfinitySingle" />
      <MemberSignature Language="DocId" Value="P:Microsoft.FSharp.Core.Operators.InfinitySingle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompiledName("InfinitySingle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Equivalent to <c>System.Single.PositiveInfinity</c></summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidArg&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T InvalidArg&lt;T&gt; (string argumentName, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T InvalidArg&lt;T&gt;(string argumentName, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.InvalidArg``1(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("invalidArg")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="argumentName" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="argumentName">The argument name.</param>
        <param name="message">The exception message.</param>
        <summary>Throw a <c>System.ArgumentException</c> exception with
 the given argument name and message.</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidOp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T InvalidOp&lt;T&gt; (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T InvalidOp&lt;T&gt;(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.InvalidOp``1(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("invalidOp")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="message">The exception message.</param>
        <summary>Throw a <c>System.InvalidOperationException</c> exception</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNull&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsNull&lt;T&gt; (T value) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static bool IsNull&lt;class T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.IsNull``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("isNull")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The value to check.</param>
        <summary>Determines whether the given value is null.</summary>
        <returns>True when value is null, false otherwise.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyValuePattern&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;TKey,TValue&gt; KeyValuePattern&lt;TKey,TValue&gt; (System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt; keyValuePair);" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;!!TKey, !!TValue&gt; KeyValuePattern&lt;TKey, TValue&gt;(valuetype System.Collections.Generic.KeyValuePair`2&lt;!!TKey, !!TValue&gt; keyValuePair) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.KeyValuePattern``2(System.Collections.Generic.KeyValuePair{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("|KeyValue|")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;TKey,TValue&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keyValuePair" Type="System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">To be added.</typeparam>
        <typeparam name="TValue">To be added.</typeparam>
        <param name="keyValuePair">The input key/value pair.</param>
        <summary>An active pattern to match values of type <c>System.Collections.Generic.KeyValuePair</c></summary>
        <returns>A tuple containing the key and value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="limitedHash&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int limitedHash&lt;T&gt; (int limit, T obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 limitedHash&lt;T&gt;(int32 limit, !!T obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.limitedHash``1(System.Int32,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="limit" Type="System.Int32" />
        <Parameter Name="obj" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="limit">The limit of nodes.</param>
        <param name="obj">The input object.</param>
        <summary>A generic hash function. This function has the same behaviour as 'hash', 
 however the default structural hashing for F# union, record and tuple 
 types stops when the given limit of nodes is reached. The exact behaviour of 
 the function can be adjusted on a type-by-type basis by implementing 
 GetHashCode for each type.</summary>
        <returns>The computed hash.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lock&lt;TLock,T&gt;">
      <MemberSignature Language="C#" Value="public static T Lock&lt;TLock,T&gt; (TLock lockObject, Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,T&gt; action) where TLock : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Lock&lt;class TLock, T&gt;(!!TLock lockObject, class Microsoft.FSharp.Core.FSharpFunc`2&lt;class Microsoft.FSharp.Core.Unit, !!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Lock``2(``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("lock")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLock">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="lockObject" Type="TLock" />
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;Microsoft.FSharp.Core.Unit,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLock">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="lockObject">The object to be locked.</param>
        <param name="action">The action to perform during the lock.</param>
        <summary>Execute the function as a mutual-exclusion region using the input value as a lock. </summary>
        <returns>The resulting value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Log&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Log&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Log``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("log")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Natural logarithm of the given number</summary>
        <returns>The natural logarithm of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Log10&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Log10&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Log10``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("log10")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Logarithm to base 10 of the given number</summary>
        <returns>The logarithm to base 10 of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Max&lt;T&gt; (T e1, T e2);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Max&lt;T&gt;(!!T e1, !!T e2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Max``1(``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("max")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="e1" Type="T" />
        <Parameter Name="e2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="e1">The first value.</param>
        <param name="e2">The second value.</param>
        <summary>Maximum based on generic comparison</summary>
        <returns>The maximum value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Min&lt;T&gt; (T e1, T e2);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Min&lt;T&gt;(!!T e1, !!T e2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Min``1(``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("min")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="e1" Type="T" />
        <Parameter Name="e2" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="e1">The first value.</param>
        <param name="e2">The second value.</param>
        <summary>Minimum based on generic comparison</summary>
        <returns>The minimum value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public static double NaN { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float64 NaN" />
      <MemberSignature Language="DocId" Value="P:Microsoft.FSharp.Core.Operators.NaN" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompiledName("NaN")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Equivalent to <c>System.Double.NaN</c></summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NaNSingle">
      <MemberSignature Language="C#" Value="public static float NaNSingle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property float32 NaNSingle" />
      <MemberSignature Language="DocId" Value="P:Microsoft.FSharp.Core.Operators.NaNSingle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompiledName("NaNSingle")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Diagnostics.DebuggerNonUserCode</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Equivalent to <c>System.Single.NaN</c></summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static bool Not (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool Not(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Not(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("not")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">The value to negate.</param>
        <summary>Negate a logical value. Not True equals False and not False equals True</summary>
        <returns>The result of the negation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NullArg&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T NullArg&lt;T&gt; (string argumentName);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T NullArg&lt;T&gt;(string argumentName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.NullArg``1(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("nullArg")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="argumentName" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="argumentName">The argument name.</param>
        <summary>Throw a <c>System.ArgumentNullException</c> exception</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static T3 op_Addition&lt;T1,T2,T3&gt; (T1 x, T2 y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T3 op_Addition&lt;T1, T2, T3&gt;(!!T1 x, !!T2 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Addition``3(``0,``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T1" />
        <Parameter Name="y" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded addition operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Append&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Collections.FSharpList&lt;T&gt; op_Append&lt;T&gt; (Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list1, Microsoft.FSharp.Collections.FSharpList&lt;T&gt; list2);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; op_Append&lt;T&gt;(class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list1, class Microsoft.FSharp.Collections.FSharpList`1&lt;!!T&gt; list2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Append``1(Microsoft.FSharp.Collections.FSharpList{``0},Microsoft.FSharp.Collections.FSharpList{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Collections.FSharpList&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="list1" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
        <Parameter Name="list2" Type="Microsoft.FSharp.Collections.FSharpList&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="list1">The first list.</param>
        <param name="list2">The second list.</param>
        <summary>Concatenate two lists.</summary>
        <returns>The concatenation of the lists.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T op_BitwiseAnd&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_BitwiseAnd&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_BitwiseAnd``1(``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded bitwise-AND operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T op_BitwiseOr&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_BitwiseOr&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_BitwiseOr``1(``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded bitwise-OR operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_ColonEquals&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void op_ColonEquals&lt;T&gt; (Microsoft.FSharp.Core.FSharpRef&lt;T&gt; cell, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname void op_ColonEquals&lt;T&gt;(class Microsoft.FSharp.Core.FSharpRef`1&lt;!!T&gt; cell, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_ColonEquals``1(Microsoft.FSharp.Core.FSharpRef{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cell" Type="Microsoft.FSharp.Core.FSharpRef&lt;T&gt;" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="cell">The cell to mutate.</param>
        <param name="value">The value to set inside the cell.</param>
        <summary>Assign to a mutable reference cell</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_ComposeLeft&lt;T2,T3,T1&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpFunc&lt;T1,T3&gt; op_ComposeLeft&lt;T2,T3,T1&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T2,T3&gt; func2, Microsoft.FSharp.Core.FSharpFunc&lt;T1,T2&gt; func1);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, !!T3&gt; op_ComposeLeft&lt;T2, T3, T1&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!T3&gt; func2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, !!T2&gt; func1) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_ComposeLeft``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpFunc&lt;T1,T3&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="T1" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="func2" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T2,T3&gt;" />
        <Parameter Name="func1" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <typeparam name="T1">To be added.</typeparam>
        <param name="func2">The second function to apply.</param>
        <param name="func1">The first function to apply.</param>
        <summary>Compose two functions, the function on the right being applied first</summary>
        <returns>The composition of the input functions.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_ComposeRight&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpFunc&lt;T1,T3&gt; op_ComposeRight&lt;T1,T2,T3&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,T2&gt; func1, Microsoft.FSharp.Core.FSharpFunc&lt;T2,T3&gt; func2);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, !!T3&gt; op_ComposeRight&lt;T1, T2, T3&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, !!T2&gt; func1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!T3&gt; func2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_ComposeRight``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpFunc&lt;T1,T3&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="func1" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,T2&gt;" />
        <Parameter Name="func2" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T2,T3&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="func1">The first function to apply.</param>
        <param name="func2">The second function to apply.</param>
        <summary>Compose two functions, the function on the left being applied first</summary>
        <returns>The composition of the input functions.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Concatenate">
      <MemberSignature Language="C#" Value="public static string op_Concatenate (string s1, string s2);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname string op_Concatenate(string s1, string s2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Concatenate(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilerMessage("This construct is for ML compatibility. Consider using the '+' operator instead. This may require a type annotation to indicate it acts on strings. This message can be disabled using '--nowarn:62' or '#nowarn "62"'.", 62, IsHidden=true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s1" Type="System.String" />
        <Parameter Name="s2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s1">To be added.</param>
        <param name="s2">To be added.</param>
        <summary>Concatenate two strings. The operator '+' may also be used.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Dereference&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T op_Dereference&lt;T&gt; (Microsoft.FSharp.Core.FSharpRef&lt;T&gt; cell);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_Dereference&lt;T&gt;(class Microsoft.FSharp.Core.FSharpRef`1&lt;!!T&gt; cell) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Dereference``1(Microsoft.FSharp.Core.FSharpRef{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cell" Type="Microsoft.FSharp.Core.FSharpRef&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="cell">The cell to dereference.</param>
        <summary>Dereference a mutable reference cell</summary>
        <returns>The value contained in the cell.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Division&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static T3 op_Division&lt;T1,T2,T3&gt; (T1 x, T2 y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T3 op_Division&lt;T1, T2, T3&gt;(!!T1 x, !!T2 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Division``3(``0,``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T1" />
        <Parameter Name="y" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded division operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool op_Equality&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname bool op_Equality&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Equality``1(``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Structural equality</summary>
        <returns>The result of the comparison.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T op_ExclusiveOr&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_ExclusiveOr&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_ExclusiveOr``1(``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded bitwise-XOR operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Exponentiation&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static T op_Exponentiation&lt;T,TResult&gt; (T x, TResult y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_Exponentiation&lt;T, TResult&gt;(!!T x, !!TResult y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Exponentiation``2(``0,``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="TResult" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="x">The input base.</param>
        <param name="y">The input exponent.</param>
        <summary>Overloaded power operator.</summary>
        <returns>The base raised to the exponent.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool op_GreaterThan&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname bool op_GreaterThan&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_GreaterThan``1(``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Structural greater-than</summary>
        <returns>The result of the comparison.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool op_GreaterThanOrEqual&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname bool op_GreaterThanOrEqual&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_GreaterThanOrEqual``1(``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Structural greater-than-or-equal</summary>
        <returns>The result of the comparison.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool op_Inequality&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname bool op_Inequality&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Inequality``1(``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Structural inequality</summary>
        <returns>The result of the comparison.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T op_LeftShift&lt;T&gt; (T value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_LeftShift&lt;T&gt;(!!T value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_LeftShift``1(``0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <param name="shift">The amount to shift.</param>
        <summary>Overloaded byte-shift left operator by a specified number of bits</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool op_LessThan&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname bool op_LessThan&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_LessThan``1(``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Structural less-than comparison</summary>
        <returns>The result of the comparison.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool op_LessThanOrEqual&lt;T&gt; (T x, T y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname bool op_LessThanOrEqual&lt;T&gt;(!!T x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_LessThanOrEqual``1(``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Structural less-than-or-equal comparison</summary>
        <returns>The result of the comparison.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LogicalNot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T op_LogicalNot&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_LogicalNot&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_LogicalNot``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Overloaded bitwise-NOT operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Modulus&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static T3 op_Modulus&lt;T1,T2,T3&gt; (T1 x, T2 y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T3 op_Modulus&lt;T1, T2, T3&gt;(!!T1 x, !!T2 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Modulus``3(``0,``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T1" />
        <Parameter Name="y" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded modulo operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Multiply&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static T3 op_Multiply&lt;T1,T2,T3&gt; (T1 x, T2 y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T3 op_Multiply&lt;T1, T2, T3&gt;(!!T1 x, !!T2 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Multiply``3(``0,``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T1" />
        <Parameter Name="y" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded multiplication operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_PipeLeft&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult op_PipeLeft&lt;T,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; func, T arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!TResult op_PipeLeft&lt;T, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; func, !!T arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_PipeLeft``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="func" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="arg1" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="func">The function.</param>
        <param name="arg1">The argument.</param>
        <summary>Apply a function to a value, the value being on the right, the function on the left</summary>
        <returns>The function result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_PipeLeft2&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult op_PipeLeft2&lt;T1,T2,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt; func, T1 arg1, T2 arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!TResult op_PipeLeft2&lt;T1, T2, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TResult&gt;&gt; func, !!T1 arg1, !!T2 arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_PipeLeft2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="func" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;" />
        <Parameter Name="arg1" Type="T1" />
        <Parameter Name="arg2" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="func">The function.</param>
        <param name="arg1">The first argument.</param>
        <param name="arg2">The second argument.</param>
        <summary>Apply a function to two values, the values being a pair on the right, the function on the left</summary>
        <returns>The function result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_PipeLeft3&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult op_PipeLeft3&lt;T1,T2,T3,TResult&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt; func, T1 arg1, T2 arg2, T3 arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!TResult op_PipeLeft3&lt;T1, T2, T3, TResult&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T3, !!TResult&gt;&gt;&gt; func, !!T1 arg1, !!T2 arg2, !!T3 arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_PipeLeft3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``0,``1,``2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="func" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt;" />
        <Parameter Name="arg1" Type="T1" />
        <Parameter Name="arg2" Type="T2" />
        <Parameter Name="arg3" Type="T3" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="func">The function.</param>
        <param name="arg1">The first argument.</param>
        <param name="arg2">The second argument.</param>
        <param name="arg3">The third argument.</param>
        <summary>Apply a function to three values, the values being a triple on the right, the function on the left</summary>
        <returns>The function result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_PipeRight&lt;T1,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult op_PipeRight&lt;T1,TResult&gt; (T1 arg, Microsoft.FSharp.Core.FSharpFunc&lt;T1,TResult&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!TResult op_PipeRight&lt;T1, TResult&gt;(!!T1 arg, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, !!TResult&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_PipeRight``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arg" Type="T1" />
        <Parameter Name="func" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="arg">The argument.</param>
        <param name="func">The function.</param>
        <summary>Apply a function to a value, the value being on the left, the function on the right</summary>
        <returns>The function result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_PipeRight2&lt;T1,T2,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult op_PipeRight2&lt;T1,T2,TResult&gt; (T1 arg1, T2 arg2, Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!TResult op_PipeRight2&lt;T1, T2, TResult&gt;(!!T1 arg1, !!T2 arg2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, !!TResult&gt;&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_PipeRight2``3(``0,``1,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arg1" Type="T1" />
        <Parameter Name="arg2" Type="T2" />
        <Parameter Name="func" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="arg1">The first argument.</param>
        <param name="arg2">The second argument.</param>
        <param name="func">The function.</param>
        <summary>Apply a function to two values, the values being a pair on the left, the function on the right</summary>
        <returns>The function result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_PipeRight3&lt;T1,T2,T3,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult op_PipeRight3&lt;T1,T2,T3,TResult&gt; (T1 arg1, T2 arg2, T3 arg3, Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!TResult op_PipeRight3&lt;T1, T2, T3, TResult&gt;(!!T1 arg1, !!T2 arg2, !!T3 arg3, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T1, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T2, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T3, !!TResult&gt;&gt;&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_PipeRight3``4(``0,``1,``2,Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="arg1" Type="T1" />
        <Parameter Name="arg2" Type="T2" />
        <Parameter Name="arg3" Type="T3" />
        <Parameter Name="func" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T1,Microsoft.FSharp.Core.FSharpFunc&lt;T2,Microsoft.FSharp.Core.FSharpFunc&lt;T3,TResult&gt;&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="arg1">The first argument.</param>
        <param name="arg2">The second argument.</param>
        <param name="arg3">The third argument.</param>
        <param name="func">The function.</param>
        <summary>Apply a function to three values, the values being a triple on the left, the function on the right</summary>
        <returns>The function result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Range&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; op_Range&lt;T&gt; (T start, T finish);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; op_Range&lt;T&gt;(!!T start, !!T finish) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Range``1(``0,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="start" Type="T" />
        <Parameter Name="finish" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="start">The start value of the range.</param>
        <param name="finish">The end value of the range.</param>
        <summary>The standard overloaded range operator, e.g. <c>[n..m]</c> for lists, <c>seq {n..m}</c> for sequences</summary>
        <returns>The sequence spanning the range.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RangeStep&lt;T,TStep&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;T&gt; op_RangeStep&lt;T,TStep&gt; (T start, TStep step, T finish);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; op_RangeStep&lt;T, TStep&gt;(!!T start, !!TStep step, !!T finish) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_RangeStep``2(``0,``1,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TStep" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="start" Type="T" />
        <Parameter Name="step" Type="TStep" />
        <Parameter Name="finish" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TStep">To be added.</typeparam>
        <param name="start">The start value of the range.</param>
        <param name="step">The step value of the range.</param>
        <param name="finish">The end value of the range.</param>
        <summary>The standard overloaded skip range operator, e.g. <c>[n..skip..m]</c> for lists, <c>seq {n..skip..m}</c> for sequences</summary>
        <returns>The sequence spanning the range using the specified step size.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T op_RightShift&lt;T&gt; (T value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_RightShift&lt;T&gt;(!!T value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_RightShift``1(``0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <param name="shift">The amount to shift.</param>
        <summary>Overloaded byte-shift right operator by a specified number of bits</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction&lt;T1,T2,T3&gt;">
      <MemberSignature Language="C#" Value="public static T3 op_Subtraction&lt;T1,T2,T3&gt; (T1 x, T2 y);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T3 op_Subtraction&lt;T1, T2, T3&gt;(!!T1 x, !!T2 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_Subtraction``3(``0,``1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T3</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
        <TypeParameter Name="T3" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T1" />
        <Parameter Name="y" Type="T2" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <typeparam name="T3">To be added.</typeparam>
        <param name="x">The first parameter.</param>
        <param name="y">The second parameter.</param>
        <summary>Overloaded subtraction operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T op_UnaryNegation&lt;T&gt; (T n);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_UnaryNegation&lt;T&gt;(!!T n) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_UnaryNegation``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="n" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="n">The value to negate.</param>
        <summary>Overloaded unary negation.</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T op_UnaryPlus&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static specialname !!T op_UnaryPlus&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.op_UnaryPlus``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Overloaded prefix-plus operator</summary>
        <returns>The result of the operation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PowInteger&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T PowInteger&lt;T&gt; (T x, int n);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T PowInteger&lt;T&gt;(!!T x, int32 n) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.PowInteger``1(``0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("pown")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="n" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input base.</param>
        <param name="n">The input exponent.</param>
        <summary>Overloaded power operator. If <c>n &gt; 0</c> then equivalent to <c>x*...*x</c> for <c>n</c> occurrences of <c>x</c>. </summary>
        <returns>The base raised to the exponent.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Raise&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Raise&lt;T&gt; (Exception exn);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Raise&lt;T&gt;(class System.Exception exn) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Raise``1(System.Exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("raise")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exn" Type="System.Exception" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="exn">The exception to raise.</param>
        <summary>Raises an exception</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ref&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpRef&lt;T&gt; Ref&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpRef`1&lt;!!T&gt; Ref&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Ref``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("ref")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpRef&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The value to contain in the cell.</param>
        <summary>Create a mutable reference cell</summary>
        <returns>The created reference cell.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reraise&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Reraise&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Reraise&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Reraise``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("reraise")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Rethrows an exception. This should only be used when handling an exception</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Rethrow&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Rethrow&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Rethrow``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("rethrow")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This function has been renamed to 'reraise'. Please adjust your code to reflect this", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Rethrows an exception. This should only be used when handling an exception</summary>
        <returns>The result value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Round&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Round&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Round``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("round")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Round the given number</summary>
        <returns>The nearest integer to the input value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int Sign&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Sign&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Sign``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sign")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Sign of the given number</summary>
        <returns>-1, 0, or 1 depending on the sign of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sin&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Sin&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Sin``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sin")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Sine of the given number</summary>
        <returns>The sine of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sinh&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Sinh&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Sinh``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sinh")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Hyperbolic sine of the given number</summary>
        <returns>The hyperbolic sine of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 SizeOf&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.SizeOf``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sizeof")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.RequiresExplicitTypeArguments</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Returns the internal size of a type in bytes. For example, <c>sizeof&lt;int&gt;</c> returns 4.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Snd&lt;T1,T2&gt;">
      <MemberSignature Language="C#" Value="public static T2 Snd&lt;T1,T2&gt; (Tuple&lt;T1,T2&gt; tuple);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T2 Snd&lt;T1, T2&gt;(class System.Tuple`2&lt;!!T1, !!T2&gt; tuple) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Snd``2(System.Tuple{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("snd")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T2</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T1" />
        <TypeParameter Name="T2" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tuple" Type="System.Tuple&lt;T1,T2&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T1">To be added.</typeparam>
        <typeparam name="T2">To be added.</typeparam>
        <param name="tuple">The input tuple.</param>
        <summary>Return the second element of a tuple, <c>snd (a,b) = b</c>.</summary>
        <returns>The second value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Sqrt&lt;T,TResult&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult Sqrt&lt;T, TResult&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Sqrt``2(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sqrt")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Square root of the given number</summary>
        <returns>The square root of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Tan&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Tan&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Tan``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tan")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Tangent of the given number</summary>
        <returns>The tangent of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Tanh&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Tanh&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Tanh``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tanh")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Hyperbolic tangent of the given number</summary>
        <returns>The hyperbolic tangent of the input.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByte&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static byte ToByte&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int8 ToByte&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToByte``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("byte")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Byte.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted byte</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToChar&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static char ToChar&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static char ToChar&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToChar``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("char")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to character. Numeric inputs are converted according to the UTF-16 
 encoding for characters. String inputs must be exactly one character long. For other
 input types the operation requires an appropriate static conversion method on the input type.</summary>
        <returns>The converted char.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDecimal&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static decimal ToDecimal&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.Decimal ToDecimal&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToDecimal``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("decimal")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to System.Decimal using a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt64.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted decimal.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDouble&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static double ToDouble&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static float64 ToDouble&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToDouble``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("float")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to 64-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Double.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted float</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToEnum&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult ToEnum&lt;TResult&gt; (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult ToEnum&lt;TResult&gt;(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToEnum``1(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("enum")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to a particular enum type.</summary>
        <returns>The converted enum type.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int ToInt&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 ToInt&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToInt``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("int")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int32.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted int</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt16&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static short ToInt16&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static int16 ToInt16&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToInt16``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("int16")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to signed 16-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int16.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted int16</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt32&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int ToInt32&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 ToInt32&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToInt32``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("int32")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to signed 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int32.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted int32</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToInt64&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static long ToInt64&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 ToInt64&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToInt64``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("int64")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to signed 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Int64.Parse()</c> 
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted int64</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToIntPtr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr ToIntPtr&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static native int ToIntPtr&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToIntPtr``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("nativeint")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to signed native integer. This is a direct conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted nativeint</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSByte&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static sbyte ToSByte&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static int8 ToSByte&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToSByte``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("sbyte")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to signed byte. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>SByte.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted sbyte</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToSingle&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static float ToSingle&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static float32 ToSingle&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToSingle``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("float32")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to 32-bit float. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>Single.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted float32</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string ToString&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static string ToString&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToString``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("string")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to a string using <c>ToString</c>.</summary>
        <returns>The converted string.</returns>
        <remarks>For standard integer and floating point values the <c>ToString</c> conversion 
 uses <c>CultureInfo.InvariantCulture</c>. </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt16&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ushort ToUInt16&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int16 ToUInt16&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToUInt16``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("uint16")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to unsigned 16-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt16.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted uint16</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt32&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static uint ToUInt32&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int32 ToUInt32&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToUInt32``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("uint32")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to unsigned 32-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt32.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted uint32</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUInt64&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ulong ToUInt64&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static unsigned int64 ToUInt64&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToUInt64``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("uint64")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to unsigned 64-bit integer. This is a direct conversion for all 
 primitive numeric types. For strings, the input is converted using <c>UInt64.Parse()</c>  
 with InvariantCulture settings. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted uint64</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToUIntPtr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static UIntPtr ToUIntPtr&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static native unsigned int ToUIntPtr&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.ToUIntPtr``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("unativeint")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.NoDynamicInvocation</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Converts the argument to unsigned native integer using a direct conversion for all 
 primitive numeric types. Otherwise the operation requires an appropriate
 static conversion method on the input type.</summary>
        <returns>The converted unativeint</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Truncate&lt;T&gt; (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Truncate&lt;T&gt;(!!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Truncate``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("truncate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The input value.</param>
        <summary>Overloaded truncate operator.</summary>
        <returns>The truncated value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUnbox&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Core.FSharpOption&lt;T&gt; TryUnbox&lt;T&gt; (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Core.FSharpOption`1&lt;!!T&gt; TryUnbox&lt;T&gt;(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.TryUnbox``1(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("tryUnbox")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Core.FSharpOption&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The boxed value.</param>
        <summary>Try to unbox a strongly typed value.</summary>
        <returns>The unboxed result as an option.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeDefOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Type TypeDefOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Type TypeDefOf&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.TypeDefOf``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("typedefof")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.RequiresExplicitTypeArguments</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Generate a System.Type representation for a type definition. If the
 input type is a generic type instantiation then return the 
 generic type definition associated with all such instantiations.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static Type TypeOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Type TypeOf&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.TypeOf``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("typeof")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.RequiresExplicitTypeArguments</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>Generate a System.Type runtime representation of a static type.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Unbox&lt;T&gt; (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static !!T Unbox&lt;T&gt;(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Unbox``1(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("unbox")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="value">The boxed value.</param>
        <summary>Unbox a strongly typed value.</summary>
        <returns>The unboxed result.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Using&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Using&lt;T,TResult&gt; (T resource, Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; action) where T : IDisposable;" />
      <MemberSignature Language="ILAsm" Value=".method public static !!TResult Using&lt;(class System.IDisposable) T, TResult&gt;(!!T resource, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Core.Operators.Using``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.4.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("using")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IDisposable</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="resource" Type="T" />
        <Parameter Name="action" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="resource">The resource to be disposed after action is called.</param>
        <param name="action">The action that accepts the resource.</param>
        <summary>Clean up resources associated with the input object after the completion of the given function.
 Cleanup occurs even when an exception is raised by the protected
 code. </summary>
        <returns>The resulting value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
