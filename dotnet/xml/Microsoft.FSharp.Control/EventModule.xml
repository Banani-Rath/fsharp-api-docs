<Type Name="EventModule" FullName="Microsoft.FSharp.Control.EventModule">
  <TypeSignature Language="C#" Value="public static class EventModule" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed EventModule extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.FSharp.Control.EventModule" />
  <TypeSignature Language="VB.NET" Value="Public Class EventModule" />
  <TypeSignature Language="F#" Value="module Event" />
  <AssemblyInfo>
    <AssemblyName>FSharp.Core</AssemblyName>
    <AssemblyVersion>4.5.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationMapping(Microsoft.FSharp.Core.SourceConstructFlags.Module)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.CompilationRepresentation(Microsoft.FSharp.Core.CompilationRepresentationFlags.ModuleSuffix)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>Microsoft.FSharp.Core.RequireQualifiedAccess</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Add&lt;T,TDel&gt;">
      <MemberSignature Language="C#" Value="public static void Add&lt;T,TDel&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt; callback, Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt; sourceEvent) where TDel : Delegate;" />
      <MemberSignature Language="ILAsm" Value=".method public static void Add&lt;T, (class System.Delegate) TDel&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.Unit&gt; callback, class Microsoft.FSharp.Control.IEvent`2&lt;!!TDel, !!T&gt; sourceEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.EventModule.Add``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Control.IEvent{``1,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Add(Of T, TDel) (callback As FSharpFunc(Of T, Unit), sourceEvent As IEvent(Of TDel, T))" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Control.Event.add : ('T -&gt; unit) -&gt; Microsoft.FSharp.Control.IEvent&lt;'Del, 'T (requires 'Del :&gt; Delegate)&gt; -&gt; unit (requires 'Del :&gt; Delegate)" Usage="Microsoft.FSharp.Control.EventModule.Add callback sourceEvent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("add")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TDel">
          <Constraints>
            <BaseTypeName>System.Delegate</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="callback" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.Unit&gt;" />
        <Parameter Name="sourceEvent" Type="Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TDel">To be added.</typeparam>
        <param name="callback">The function to call when the event is triggered.</param>
        <param name="sourceEvent">The input event.</param>
        <summary>Runs the given function each time the given event is triggered.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Choose&lt;T,TResult,TDel&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;TResult&gt;,TResult&gt; Choose&lt;T,TResult,TDel&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt; chooser, Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt; sourceEvent) where TDel : Delegate;" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.IEvent`2&lt;class Microsoft.FSharp.Control.FSharpHandler`1&lt;!!TResult&gt;, !!TResult&gt; Choose&lt;T, TResult, (class System.Delegate) TDel&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpOption`1&lt;!!TResult&gt;&gt; chooser, class Microsoft.FSharp.Control.IEvent`2&lt;!!TDel, !!T&gt; sourceEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.EventModule.Choose``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Control.IEvent{``2,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Choose(Of T, TResult, TDel) (chooser As FSharpFunc(Of T, FSharpOption(Of TResult)), sourceEvent As IEvent(Of TDel, T)) As IEvent(Of FSharpHandler(Of TResult), TResult)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Control.Event.choose : ('T -&gt; option&lt;'Result&gt;) -&gt; Microsoft.FSharp.Control.IEvent&lt;'Del, 'T (requires 'Del :&gt; Delegate)&gt; -&gt; Microsoft.FSharp.Control.IEvent&lt;Handler&lt;'Result&gt;, 'Result&gt; (requires 'Del :&gt; Delegate)" Usage="Microsoft.FSharp.Control.EventModule.Choose chooser sourceEvent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("choose")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;TResult&gt;,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
        <TypeParameter Name="TDel">
          <Constraints>
            <BaseTypeName>System.Delegate</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="chooser" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpOption&lt;TResult&gt;&gt;" />
        <Parameter Name="sourceEvent" Type="Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <typeparam name="TDel">To be added.</typeparam>
        <param name="chooser">The function to select and transform event values to pass on.</param>
        <param name="sourceEvent">The input event.</param>
        <summary>Returns a new event which fires on a selection of messages from the original event.
 The selection function takes an original message to an optional new message.</summary>
        <returns>An event that fires only when the chooser returns Some.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter&lt;T,TDel&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;T&gt;,T&gt; Filter&lt;T,TDel&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt; sourceEvent) where TDel : Delegate;" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.IEvent`2&lt;class Microsoft.FSharp.Control.FSharpHandler`1&lt;!!T&gt;, !!T&gt; Filter&lt;T, (class System.Delegate) TDel&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Control.IEvent`2&lt;!!TDel, !!T&gt; sourceEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.EventModule.Filter``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Control.IEvent{``1,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Filter(Of T, TDel) (predicate As FSharpFunc(Of T, Boolean), sourceEvent As IEvent(Of TDel, T)) As IEvent(Of FSharpHandler(Of T), T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Control.Event.filter : ('T -&gt; bool) -&gt; Microsoft.FSharp.Control.IEvent&lt;'Del, 'T (requires 'Del :&gt; Delegate)&gt; -&gt; Microsoft.FSharp.Control.IEvent&lt;Handler&lt;'T&gt;, 'T&gt; (requires 'Del :&gt; Delegate)" Usage="Microsoft.FSharp.Control.EventModule.Filter predicate sourceEvent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("filter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;T&gt;,T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TDel">
          <Constraints>
            <BaseTypeName>System.Delegate</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="sourceEvent" Type="Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TDel">To be added.</typeparam>
        <param name="predicate">The function to determine which triggers from the event to propagate.</param>
        <param name="sourceEvent">The input event.</param>
        <summary>Returns a new event that listens to the original event and triggers the resulting
 event only when the argument to the event passes the given function.</summary>
        <returns>An event that only passes values that pass the predicate.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Map&lt;T,TResult,TDel&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;TResult&gt;,TResult&gt; Map&lt;T,TResult,TDel&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt; mapping, Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt; sourceEvent) where TDel : Delegate;" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.IEvent`2&lt;class Microsoft.FSharp.Control.FSharpHandler`1&lt;!!TResult&gt;, !!TResult&gt; Map&lt;T, TResult, (class System.Delegate) TDel&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt; mapping, class Microsoft.FSharp.Control.IEvent`2&lt;!!TDel, !!T&gt; sourceEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.EventModule.Map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.IEvent{``2,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Map(Of T, TResult, TDel) (mapping As FSharpFunc(Of T, TResult), sourceEvent As IEvent(Of TDel, T)) As IEvent(Of FSharpHandler(Of TResult), TResult)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Control.Event.map : ('T -&gt; 'Result) -&gt; Microsoft.FSharp.Control.IEvent&lt;'Del, 'T (requires 'Del :&gt; Delegate)&gt; -&gt; Microsoft.FSharp.Control.IEvent&lt;Handler&lt;'Result&gt;, 'Result&gt; (requires 'Del :&gt; Delegate)" Usage="Microsoft.FSharp.Control.EventModule.Map mapping sourceEvent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("map")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;TResult&gt;,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult" />
        <TypeParameter Name="TDel">
          <Constraints>
            <BaseTypeName>System.Delegate</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="mapping" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;" />
        <Parameter Name="sourceEvent" Type="Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <typeparam name="TDel">To be added.</typeparam>
        <param name="mapping">To be added.</param>
        <param name="sourceEvent">The input event.</param>
        <summary>Returns a new event that passes values transformed by the given function.</summary>
        <returns>An event that passes the transformed values.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Merge&lt;TDel1,T,TDel2&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;T&gt;,T&gt; Merge&lt;TDel1,T,TDel2&gt; (Microsoft.FSharp.Control.IEvent&lt;TDel1,T&gt; event1, Microsoft.FSharp.Control.IEvent&lt;TDel2,T&gt; event2) where TDel1 : Delegate where TDel2 : Delegate;" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.IEvent`2&lt;class Microsoft.FSharp.Control.FSharpHandler`1&lt;!!T&gt;, !!T&gt; Merge&lt;(class System.Delegate) TDel1, T, (class System.Delegate) TDel2&gt;(class Microsoft.FSharp.Control.IEvent`2&lt;!!TDel1, !!T&gt; event1, class Microsoft.FSharp.Control.IEvent`2&lt;!!TDel2, !!T&gt; event2) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.EventModule.Merge``3(Microsoft.FSharp.Control.IEvent{``0,``1},Microsoft.FSharp.Control.IEvent{``2,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Merge(Of TDel1 As Delegate, T As Delegate, TDel2 As Delegate) (event1 As IEvent(Of TDel1, T), event2 As IEvent(Of TDel2, T)) As IEvent(Of FSharpHandler(Of T), T)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Control.Event.merge : Microsoft.FSharp.Control.IEvent&lt;'TDel1, 'T (requires 'TDel1 :&gt; Delegate)&gt; -&gt; Microsoft.FSharp.Control.IEvent&lt;'TDel2, 'T (requires 'TDel2 :&gt; Delegate)&gt; -&gt; Microsoft.FSharp.Control.IEvent&lt;Handler&lt;'T&gt;, 'T&gt; (requires 'TDel1 :&gt; Delegate and 'TDel2 :&gt; Delegate)" Usage="Microsoft.FSharp.Control.EventModule.Merge event1 event2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("merge")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;T&gt;,T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDel1">
          <Constraints>
            <BaseTypeName>System.Delegate</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="T" />
        <TypeParameter Name="TDel2">
          <Constraints>
            <BaseTypeName>System.Delegate</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="event1" Type="Microsoft.FSharp.Control.IEvent&lt;TDel1,T&gt;" />
        <Parameter Name="event2" Type="Microsoft.FSharp.Control.IEvent&lt;TDel2,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDel1">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TDel2">To be added.</typeparam>
        <param name="event1">The first input event.</param>
        <param name="event2">The second input event.</param>
        <summary>Fires the output event when either of the input events fire.</summary>
        <returns>An event that fires when either of the input events fire.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pairwise&lt;TDel,T&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;Tuple&lt;T,T&gt;&gt;,Tuple&lt;T,T&gt;&gt; Pairwise&lt;TDel,T&gt; (Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt; sourceEvent) where TDel : Delegate;" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.IEvent`2&lt;class Microsoft.FSharp.Control.FSharpHandler`1&lt;class System.Tuple`2&lt;!!T, !!T&gt;&gt;, class System.Tuple`2&lt;!!T, !!T&gt;&gt; Pairwise&lt;(class System.Delegate) TDel, T&gt;(class Microsoft.FSharp.Control.IEvent`2&lt;!!TDel, !!T&gt; sourceEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.EventModule.Pairwise``2(Microsoft.FSharp.Control.IEvent{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pairwise(Of TDel As Delegate, T As Delegate) (sourceEvent As IEvent(Of TDel, T)) As IEvent(Of FSharpHandler(Of Tuple(Of T, T)), Tuple(Of T, T))" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Control.Event.pairwise : Microsoft.FSharp.Control.IEvent&lt;'Del, 'T (requires 'Del :&gt; Delegate)&gt; -&gt; Microsoft.FSharp.Control.IEvent&lt;Handler&lt;'T * 'T&gt;, 'T * 'T&gt; (requires 'Del :&gt; Delegate)" Usage="Microsoft.FSharp.Control.EventModule.Pairwise sourceEvent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("pairwise")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;System.Tuple&lt;T,T&gt;&gt;,System.Tuple&lt;T,T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDel">
          <Constraints>
            <BaseTypeName>System.Delegate</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="sourceEvent" Type="Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TDel">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <param name="sourceEvent">The input event.</param>
        <summary>Returns a new event that triggers on the second and subsequent triggerings of the input event.
 The Nth triggering of the input event passes the arguments from the N-1th and Nth triggering as
 a pair. The argument passed to the N-1th triggering is held in hidden internal state until the 
 Nth triggering occurs.</summary>
        <returns>An event that triggers on pairs of consecutive values passed from the source event.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Partition&lt;T,TDel&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;T&gt;,T&gt;,Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;T&gt;,T&gt;&gt; Partition&lt;T,TDel&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,bool&gt; predicate, Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt; sourceEvent) where TDel : Delegate;" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;class Microsoft.FSharp.Control.IEvent`2&lt;class Microsoft.FSharp.Control.FSharpHandler`1&lt;!!T&gt;, !!T&gt;, class Microsoft.FSharp.Control.IEvent`2&lt;class Microsoft.FSharp.Control.FSharpHandler`1&lt;!!T&gt;, !!T&gt;&gt; Partition&lt;T, (class System.Delegate) TDel&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, bool&gt; predicate, class Microsoft.FSharp.Control.IEvent`2&lt;!!TDel, !!T&gt; sourceEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.EventModule.Partition``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Control.IEvent{``1,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Partition(Of T, TDel) (predicate As FSharpFunc(Of T, Boolean), sourceEvent As IEvent(Of TDel, T)) As Tuple(Of IEvent(Of FSharpHandler(Of T), T), IEvent(Of FSharpHandler(Of T), T))" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Control.Event.partition : ('T -&gt; bool) -&gt; Microsoft.FSharp.Control.IEvent&lt;'Del, 'T (requires 'Del :&gt; Delegate)&gt; -&gt; Microsoft.FSharp.Control.IEvent&lt;Handler&lt;'T&gt;, 'T&gt; * Microsoft.FSharp.Control.IEvent&lt;Handler&lt;'T&gt;, 'T&gt; (requires 'Del :&gt; Delegate)" Usage="Microsoft.FSharp.Control.EventModule.Partition predicate sourceEvent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("partition")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;T&gt;,T&gt;,Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;T&gt;,T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TDel">
          <Constraints>
            <BaseTypeName>System.Delegate</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="predicate" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,System.Boolean&gt;" />
        <Parameter Name="sourceEvent" Type="Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TDel">To be added.</typeparam>
        <param name="predicate">The function to determine which output event to trigger.</param>
        <param name="sourceEvent">The input event.</param>
        <summary>Returns a new event that listens to the original event and triggers the 
 first resulting event if the application of the predicate to the event arguments
 returned true, and the second event if it returned false.</summary>
        <returns>A tuple of events.  The first is triggered when the predicate evaluates to true
 and the second when the predicate evaluates to false.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scan&lt;TResult,T,TDel&gt;">
      <MemberSignature Language="C#" Value="public static Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;TResult&gt;,TResult&gt; Scan&lt;TResult,T,TDel&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;TResult,Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;&gt; collector, TResult state, Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt; sourceEvent) where TDel : Delegate;" />
      <MemberSignature Language="ILAsm" Value=".method public static class Microsoft.FSharp.Control.IEvent`2&lt;class Microsoft.FSharp.Control.FSharpHandler`1&lt;!!TResult&gt;, !!TResult&gt; Scan&lt;TResult, T, (class System.Delegate) TDel&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!TResult, class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, !!TResult&gt;&gt; collector, !!TResult state, class Microsoft.FSharp.Control.IEvent`2&lt;!!TDel, !!T&gt; sourceEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.EventModule.Scan``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Control.IEvent{``2,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Scan(Of TResult, T, TDel) (collector As FSharpFunc(Of TResult, FSharpFunc(Of T, TResult)), state As TResult, sourceEvent As IEvent(Of TDel, T)) As IEvent(Of FSharpHandler(Of TResult), TResult)" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Control.Event.scan : ('Result -&gt; 'T -&gt; 'Result) -&gt; 'Result -&gt; Microsoft.FSharp.Control.IEvent&lt;'Del, 'T (requires 'Del :&gt; Delegate)&gt; -&gt; Microsoft.FSharp.Control.IEvent&lt;Handler&lt;'Result&gt;, 'Result&gt; (requires 'Del :&gt; Delegate)" Usage="Microsoft.FSharp.Control.EventModule.Scan collector state sourceEvent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("scan")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;TResult&gt;,TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
        <TypeParameter Name="T" />
        <TypeParameter Name="TDel">
          <Constraints>
            <BaseTypeName>System.Delegate</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="collector" Type="Microsoft.FSharp.Core.FSharpFunc&lt;TResult,Microsoft.FSharp.Core.FSharpFunc&lt;T,TResult&gt;&gt;" />
        <Parameter Name="state" Type="TResult" />
        <Parameter Name="sourceEvent" Type="Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">To be added.</typeparam>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TDel">To be added.</typeparam>
        <param name="collector">The function to update the state with each event value.</param>
        <param name="state">The initial state.</param>
        <param name="sourceEvent">The input event.</param>
        <summary>Returns a new event consisting of the results of applying the given accumulating function
 to successive values triggered on the input event.  An item of internal state
 records the current value of the state parameter.  The internal state is not locked during the
 execution of the accumulation function, so care should be taken that the 
 input IEvent not triggered by multiple threads simultaneously.</summary>
        <returns>An event that fires on the updated state values.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split&lt;T,TResult1,TResult2,TDel&gt;">
      <MemberSignature Language="C#" Value="public static Tuple&lt;Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;TResult1&gt;,TResult1&gt;,Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;TResult2&gt;,TResult2&gt;&gt; Split&lt;T,TResult1,TResult2,TDel&gt; (Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpChoice&lt;TResult1,TResult2&gt;&gt; splitter, Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt; sourceEvent) where TDel : Delegate;" />
      <MemberSignature Language="ILAsm" Value=".method public static class System.Tuple`2&lt;class Microsoft.FSharp.Control.IEvent`2&lt;class Microsoft.FSharp.Control.FSharpHandler`1&lt;!!TResult1&gt;, !!TResult1&gt;, class Microsoft.FSharp.Control.IEvent`2&lt;class Microsoft.FSharp.Control.FSharpHandler`1&lt;!!TResult2&gt;, !!TResult2&gt;&gt; Split&lt;T, TResult1, TResult2, (class System.Delegate) TDel&gt;(class Microsoft.FSharp.Core.FSharpFunc`2&lt;!!T, class Microsoft.FSharp.Core.FSharpChoice`2&lt;!!TResult1, !!TResult2&gt;&gt; splitter, class Microsoft.FSharp.Control.IEvent`2&lt;!!TDel, !!T&gt; sourceEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.FSharp.Control.EventModule.Split``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Control.IEvent{``3,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Split(Of T, TResult1, TResult2, TDel) (splitter As FSharpFunc(Of T, FSharpChoice(Of TResult1, TResult2)), sourceEvent As IEvent(Of TDel, T)) As Tuple(Of IEvent(Of FSharpHandler(Of TResult1), TResult1), IEvent(Of FSharpHandler(Of TResult2), TResult2))" />
      <MemberSignature Language="F#" Value="Microsoft.FSharp.Control.Event.split : ('T -&gt; Choice&lt;'TResult1, 'TResult2&gt;) -&gt; Microsoft.FSharp.Control.IEvent&lt;'Del, 'T (requires 'Del :&gt; Delegate)&gt; -&gt; Microsoft.FSharp.Control.IEvent&lt;Handler&lt;'TResult1&gt;, 'TResult1&gt; * Microsoft.FSharp.Control.IEvent&lt;Handler&lt;'TResult2&gt;, 'TResult2&gt; (requires 'Del :&gt; Delegate)" Usage="Microsoft.FSharp.Control.EventModule.Split splitter sourceEvent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>FSharp.Core</AssemblyName>
        <AssemblyVersion>4.5.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationArgumentCounts(Mono.Cecil.CustomAttributeArgument[])</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>Microsoft.FSharp.Core.CompilationSourceName("split")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Tuple&lt;Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;TResult1&gt;,TResult1&gt;,Microsoft.FSharp.Control.IEvent&lt;Microsoft.FSharp.Control.FSharpHandler&lt;TResult2&gt;,TResult2&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
        <TypeParameter Name="TResult1" />
        <TypeParameter Name="TResult2" />
        <TypeParameter Name="TDel">
          <Constraints>
            <BaseTypeName>System.Delegate</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="splitter" Type="Microsoft.FSharp.Core.FSharpFunc&lt;T,Microsoft.FSharp.Core.FSharpChoice&lt;TResult1,TResult2&gt;&gt;" />
        <Parameter Name="sourceEvent" Type="Microsoft.FSharp.Control.IEvent&lt;TDel,T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult1">To be added.</typeparam>
        <typeparam name="TResult2">To be added.</typeparam>
        <typeparam name="TDel">To be added.</typeparam>
        <param name="splitter">The function to transform event values into one of two types.</param>
        <param name="sourceEvent">The input event.</param>
        <summary>Returns a new event that listens to the original event and triggers the 
 first resulting event if the application of the function to the event arguments
 returned a Choice1Of2, and the second event if it returns a Choice2Of2.</summary>
        <returns>A tuple of events.  The first fires whenever <c>splitter</c> evaluates to Choice1of1 and
 the second fires whenever <c>splitter</c> evaluates to Choice2of2.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>